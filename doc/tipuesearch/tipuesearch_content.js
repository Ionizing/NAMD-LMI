var tipuesearch = {"pages":[{"title":" NAMD Luminescense ","text":"NAMD Luminescense This is my Fortran project! NAMD with luminescence [X] Add optical feild [ ] Add decoherence [ ] Test for remove detailed balance factor [ ] Test for smaller time step Developer Info Ionizing","tags":"home","loc":"index.html"},{"title":"wavecar – NAMD Luminescense ","text":"type, public :: wavecar Contents Variables iu filelen reclen prec nspin nkpoints nbands encut efermi acell bcell volume ngrid wavetype gvecs nplws kvecs eigs fweights Components Type Visibility Attributes Name Initial integer, public :: iu integer, public :: filelen integer, public :: reclen integer, public :: prec integer, public :: nspin integer, public :: nkpoints integer, public :: nbands real(kind=q), public :: encut real(kind=q), public :: efermi real(kind=q), public :: acell (3,3) real(kind=q), public :: bcell (3,3) real(kind=q), public :: volume integer, public :: ngrid (3) character(len=8), public :: wavetype integer, public, ALLOCATABLE :: gvecs (:,:,:) integer, public, ALLOCATABLE :: nplws (:) real(kind=q), public, ALLOCATABLE :: kvecs (:,:) real(kind=q), public, ALLOCATABLE :: eigs (:,:,:) real(kind=q), public, ALLOCATABLE :: fweights (:,:,:)","tags":"","loc":"type/wavecar.html"},{"title":"input – NAMD Luminescense ","text":"type, public :: input Contents Variables rundir wavetype ikpoint brange basis_up basis_dn nsw ndigit namdtime dt nsample ntraj propmethod shmethod nelm lreal fname temperature scissor inibands inispins inisteps efield Components Type Visibility Attributes Name Initial character(len=256), public :: rundir = \"../run\" the directory where '0001' '0001' lies in character(len=8), public :: wavetype = \"std\" WAVECAR type, should be 'std' 'gamx' 'gamz' or 'ncl' integer, public :: ikpoint = 1 kpoint index, counts from 1 integer, public :: brange (2) = [0, 0] band index range for NAC calculation, counts from 1 integer, public :: basis_up (2) = [0, 0] basis range for spin up integer, public :: basis_dn (2) = [0, 0] basis range for spin down integer, public :: nsw = 0 NSW integer, public :: ndigit = 4 the number of digits for each step index. 4 for '0001', 5 for '00001' integer, public :: namdtime = 1000 number of steps performed by NAMD real(kind=q), public :: dt = 1.0 time step, in fs integer, public :: nsample = 100 number of samplings from total trajectory integer, public :: ntraj = 10000 number of hopping samples\nthe method used for propagation, available: \"FINITE-DIFFERENCE\", \"EXACT\", \"LIOUVILLE-TROTTER\" character(len=32), public :: propmethod = \"EXACT\" the method used for surface hopping, available: \"FSSH\" character(len=32), public :: shmethod = \"FSSH\" electronic steps for each ionic steps in propagation, different propmethod corresponds different nelms\nwe suggest: \"FINITE-DIFFERENCE\"=>1000, \"EXACT\"=>1, \"LIOUVILLE-TROTTER\"=>1 integer, public :: nelm = 1 logical, public :: lreal = .FALSE. Use real NAC or not character(len=256), public :: fname = \"NAC.h5\" file name for saving NAC data real(kind=q), public :: temperature = 300.0 NAMD temperature, in Kelvin real(kind=q), public :: scissor = 0.0 Value for scissor operator, in eV TODO integer, public, ALLOCATABLE :: inibands (:) integer, public, ALLOCATABLE :: inispins (:) integer, public, ALLOCATABLE :: inisteps (:) For EFIELD real(kind=q), public, ALLOCATABLE :: efield (:,:) External electric field, [3, namdtime], in V/Angstrom","tags":"","loc":"type/input.html"},{"title":"version – NAMD Luminescense ","text":"type, public :: version Contents Variables major minor patch datetime commit Components Type Visibility Attributes Name Initial integer, public :: major integer, public :: minor integer, public :: patch character(len=32), public :: datetime character(len=64), public :: commit","tags":"","loc":"type/version.html"},{"title":"surface_hopping – NAMD Luminescense ","text":"type, public :: surface_hopping Contents Variables shmethod propmethod ntraj sh_prob sh_pops sh_eigs Components Type Visibility Attributes Name Initial character(len=32), public :: shmethod character(len=32), public :: propmethod integer, public :: ntraj real(kind=q), public, ALLOCATABLE :: sh_prob (:,:,:) real(kind=q), public, ALLOCATABLE :: sh_pops (:,:) real(kind=q), public, ALLOCATABLE :: sh_eigs (:)","tags":"","loc":"type/surface_hopping.html"},{"title":"wavecar_m33det_ – NAMD Luminescense","text":"public function wavecar_m33det_(acell) Arguments Type Intent Optional Attributes Name real(kind=q), intent(in) :: acell (3,3) Return Value real(kind=q) Contents None","tags":"","loc":"proc/wavecar_m33det_.html"},{"title":"wavecar_init – NAMD Luminescense","text":"public subroutine wavecar_init(wav, fname, wavetype, iu0, lgvecs) Arguments Type Intent Optional Attributes Name type( wavecar ), intent(out) :: wav character(len=*), intent(in) :: fname character(len=*), intent(in) :: wavetype integer, intent(in), optional :: iu0 logical, intent(in), optional :: lgvecs local variables Contents None","tags":"","loc":"proc/wavecar_init.html"},{"title":"wavecar_destroy – NAMD Luminescense","text":"public subroutine wavecar_destroy(wav) Arguments Type Intent Optional Attributes Name type( wavecar ), intent(inout) :: wav Contents None","tags":"","loc":"proc/wavecar_destroy.html"},{"title":"wavecar_read_wavefunction_qs – NAMD Luminescense","text":"public subroutine wavecar_read_wavefunction_qs(wav, ispin, ikpoint, iband, phi, lnorm) Arguments Type Intent Optional Attributes Name type( wavecar ), intent(in) :: wav integer, intent(in) :: ispin integer, intent(in) :: ikpoint integer, intent(in) :: iband complex(kind=qs), intent(out) :: phi (wav%nplws(ikpoint)) logical, optional :: lnorm local variables Contents None","tags":"","loc":"proc/wavecar_read_wavefunction_qs.html"},{"title":"wavecar_read_wavefunction_q – NAMD Luminescense","text":"public subroutine wavecar_read_wavefunction_q(wav, ispin, ikpoint, iband, phi, lnorm) Arguments Type Intent Optional Attributes Name type( wavecar ), intent(in) :: wav integer, intent(in) :: ispin integer, intent(in) :: ikpoint integer, intent(in) :: iband complex(kind=q), intent(out) :: phi (wav%nplws(ikpoint)) logical, optional :: lnorm local variables Contents None","tags":"","loc":"proc/wavecar_read_wavefunction_q.html"},{"title":"wavecar_get_gvecs_cart – NAMD Luminescense","text":"public subroutine wavecar_get_gvecs_cart(wav, ikpoint, gvecs_cart) Arguments Type Intent Optional Attributes Name type( wavecar ), intent(in) :: wav integer, intent(in) :: ikpoint real(kind=q), intent(out) :: gvecs_cart (:,:) local variables Contents None","tags":"","loc":"proc/wavecar_get_gvecs_cart.html"},{"title":"wavecar_acell2bcell_ – NAMD Luminescense","text":"public subroutine wavecar_acell2bcell_(A, B) Arguments Type Intent Optional Attributes Name real(kind=q), intent(in) :: A (3,3) real(kind=q), intent(out) :: B (3,3) local variables Contents None","tags":"","loc":"proc/wavecar_acell2bcell_.html"},{"title":"wavecar_gen_gvecs_all_k_ – NAMD Luminescense","text":"public subroutine wavecar_gen_gvecs_all_k_(wav) Arguments Type Intent Optional Attributes Name type( wavecar ), intent(inout) :: wav local variables Contents None","tags":"","loc":"proc/wavecar_gen_gvecs_all_k_.html"},{"title":"wavecar_gen_gvecs_single_k_ – NAMD Luminescense","text":"public subroutine wavecar_gen_gvecs_single_k_(bcell, kvec, ngrid, encut, ngvec, wavetype, gvec) Filtering the gvectors for gamma-only version Arguments Type Intent Optional Attributes Name real(kind=q), intent(in) :: bcell (3,3) real(kind=q), intent(in) :: kvec (3) integer, intent(in) :: ngrid (3) real(kind=q), intent(in) :: encut integer, intent(in) :: ngvec character(len=*), intent(in) :: wavetype integer, intent(inout) :: gvec (:,:) local variables Contents None","tags":"","loc":"proc/wavecar_gen_gvecs_single_k_.html"},{"title":"wavecar_gen_fft_freq_ – NAMD Luminescense","text":"public subroutine wavecar_gen_fft_freq_(ng, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ng integer, intent(out) :: g (:) local variable Contents None","tags":"","loc":"proc/wavecar_gen_fft_freq_.html"},{"title":"wavecar_read_wavefunction – NAMD Luminescense","text":"public interface wavecar_read_wavefunction Contents Module Procedures wavecar_read_wavefunction_q wavecar_read_wavefunction_qs Module Procedures public subroutine wavecar_read_wavefunction_q (wav, ispin, ikpoint, iband, phi, lnorm) Arguments Type Intent Optional Attributes Name type( wavecar ), intent(in) :: wav integer, intent(in) :: ispin integer, intent(in) :: ikpoint integer, intent(in) :: iband complex(kind=q), intent(out) :: phi (wav%nplws(ikpoint)) logical, optional :: lnorm local variables public subroutine wavecar_read_wavefunction_qs (wav, ispin, ikpoint, iband, phi, lnorm) Arguments Type Intent Optional Attributes Name type( wavecar ), intent(in) :: wav integer, intent(in) :: ispin integer, intent(in) :: ikpoint integer, intent(in) :: iband complex(kind=qs), intent(out) :: phi (wav%nplws(ikpoint)) logical, optional :: lnorm local variables","tags":"","loc":"interface/wavecar_read_wavefunction.html"},{"title":"input_from_file – NAMD Luminescense","text":"public subroutine input_from_file(inp, fname, llog) Arguments Type Intent Optional Attributes Name type( input ), intent(out) :: inp character, intent(in), optional :: fname logical, intent(in), optional :: llog Contents None","tags":"","loc":"proc/input_from_file.html"},{"title":"input_to_file – NAMD Luminescense","text":"public subroutine input_to_file(inp, fname) Arguments Type Intent Optional Attributes Name type( input ), intent(in) :: inp character, intent(in), optional :: fname Contents None","tags":"","loc":"proc/input_to_file.html"},{"title":"input_destroy – NAMD Luminescense","text":"public subroutine input_destroy(inp) Arguments Type Intent Optional Attributes Name type( input ), intent(inout) :: inp Contents None","tags":"","loc":"proc/input_destroy.html"},{"title":"input_example – NAMD Luminescense","text":"public subroutine input_example(nsw, nsample, fname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nsw integer, intent(in) :: nsample character, intent(in) :: fname local variables Contents None","tags":"","loc":"proc/input_example.html"},{"title":"input_mpisync – NAMD Luminescense","text":"public subroutine input_mpisync(inp) Uses mpi Arguments Type Intent Optional Attributes Name type( input ), intent(inout) :: inp Contents None","tags":"","loc":"proc/input_mpisync.html"},{"title":"cli_parse – NAMD Luminescense","text":"subroutine cli_parse() These three registries are required by -e or --inp-example Arguments None Contents None","tags":"","loc":"proc/cli_parse.html"},{"title":"randint_range – NAMD Luminescense","text":"public function randint_range(low, high) result(ret) Generate uniformly distributed random integer in closed interval [low, high] Arguments Type Intent Optional Attributes Name integer, intent(in) :: low integer, intent(in) :: high Return Value integer Contents None","tags":"","loc":"proc/randint_range.html"},{"title":"version_print – NAMD Luminescense","text":"public subroutine version_print(ver, io, str) Arguments Type Intent Optional Attributes Name type( version ), intent(in) :: ver integer, intent(in), optional :: io character, intent(inout), optional :: str Contents None","tags":"","loc":"proc/version_print.html"},{"title":"mpi_partition – NAMD Luminescense","text":"public pure subroutine mpi_partition(nrank, length, sendcounts, displs) Partition the indices\nPlease make sure the nrank <= length, or the sendcounts[i] contains 0, which may cause fatal error with MPI\nDeal with indivisible length\ncumulative sum Arguments Type Intent Optional Attributes Name integer, intent(in) :: nrank integer, intent(in) :: length integer, intent(out) :: sendcounts (nrank) integer, intent(out) :: displs (nrank) local variables Contents None","tags":"","loc":"proc/mpi_partition.html"},{"title":"init_random_seed – NAMD Luminescense","text":"public subroutine init_random_seed() Initialize the random seed, https://gcc.gnu.org/onlinedocs/gcc-4.4.7/gfortran/RANDOM_005fSEED.html Arguments None Contents None","tags":"","loc":"proc/init_random_seed.html"},{"title":"qsort_i – NAMD Luminescense","text":"public recursive subroutine qsort_i(A) Sort integer array in ascending order Arguments Type Intent Optional Attributes Name integer, intent(inout) :: A (:) Contents None","tags":"","loc":"proc/qsort_i.html"},{"title":"qsort_partition_ – NAMD Luminescense","text":"public subroutine qsort_partition_(A, p) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: A (:) integer, intent(inout) :: p Contents None","tags":"","loc":"proc/qsort_partition_.html"},{"title":"cumtrapz – NAMD Luminescense","text":"public subroutine cumtrapz(ys, dx, ret) Arguments Type Intent Optional Attributes Name real(kind=q), intent(in) :: ys (:) real(kind=q), intent(in) :: dx real(kind=q), intent(out) :: ret (:) Contents None","tags":"","loc":"proc/cumtrapz.html"},{"title":"self_correlate_function – NAMD Luminescense","text":"public subroutine self_correlate_function(a, ret) Arguments Type Intent Optional Attributes Name real(kind=q), intent(in) :: a (:) size(a) = n real(kind=q), intent(out) :: ret (:) size(ret) = n-1 Contents None","tags":"","loc":"proc/self_correlate_function.html"},{"title":"cumsum – NAMD Luminescense","text":"public interface cumsum Contents Module Procedures cumsum_i cumsum_f Module Procedures private pure subroutine cumsum_i(a, b) Arguments Type Intent Optional Attributes Name integer, intent(in) :: a (:) integer, intent(out) :: b (SIZE(a)) private pure subroutine cumsum_f(a, b) Arguments Type Intent Optional Attributes Name real(kind=q), intent(in) :: a (:) real(kind=q), intent(out) :: b (SIZE(a))","tags":"","loc":"interface/cumsum.html"},{"title":"lower_bound – NAMD Luminescense","text":"public interface lower_bound Contents Module Procedures lower_bound_f Module Procedures private pure function lower_bound_f(A, val) result(ret) Arguments Type Intent Optional Attributes Name real(kind=q), intent(in) :: A (:) real(kind=q), intent(in) :: val Return Value integer local variables","tags":"","loc":"interface/lower_bound.html"},{"title":"int2str – NAMD Luminescense","text":"public recursive function int2str(x, fmt, ndigit) result(ret) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x character, intent(in), optional :: fmt integer, intent(in), optional :: ndigit Return Value character(len=32) Contents None","tags":"","loc":"proc/int2str.html"},{"title":"real2str – NAMD Luminescense","text":"public function real2str(x, fmt) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x character, intent(in), optional :: fmt Return Value character(len=32) Contents None","tags":"","loc":"proc/real2str.html"},{"title":"generate_static_calculation_path – NAMD Luminescense","text":"public function generate_static_calculation_path(rundir, idx, ndigit) result(ret) Arguments Type Intent Optional Attributes Name character, intent(in) :: rundir integer, intent(in) :: idx integer, intent(in) :: ndigit Return Value character(len=256) Contents None","tags":"","loc":"proc/generate_static_calculation_path.html"},{"title":"toupper – NAMD Luminescense","text":"public pure function toupper(str) result(ret) Arguments Type Intent Optional Attributes Name character, intent(in) :: str Return Value character(len=LEN) Contents None","tags":"","loc":"proc/toupper.html"},{"title":"tolower – NAMD Luminescense","text":"public pure function tolower(str) result(ret) Arguments Type Intent Optional Attributes Name character, intent(in) :: str Return Value character(len=LEN) Contents None","tags":"","loc":"proc/tolower.html"},{"title":"tdm_get_tdm_pseudo_qs – NAMD Luminescense","text":"public function tdm_get_tdm_pseudo_qs(phi_i, phi_j, k, de, wavetype) result(ret) Arguments Type Intent Optional Attributes Name complex(kind=qs), intent(in) :: phi_i (:) complex(kind=qs), intent(in) :: phi_j (:) real(kind=q), intent(in) :: k (:,:) real(kind=q), intent(in) :: de character, intent(in) :: wavetype Return Value complex(kind=q)(3) local variables Contents None","tags":"","loc":"proc/tdm_get_tdm_pseudo_qs.html"},{"title":"tdm_get_tdm_pseudo_q – NAMD Luminescense","text":"public function tdm_get_tdm_pseudo_q(phi_i, phi_j, k, de, wavetype) result(ret) phi_j(n)' * phi_i(n) Arguments Type Intent Optional Attributes Name complex(kind=q), intent(in) :: phi_i (:) complex(kind=q), intent(in) :: phi_j (:) real(kind=q), intent(in) :: k (:,:) real(kind=q), intent(in) :: de character, intent(in) :: wavetype Return Value complex(kind=q)(3) local variables Contents None","tags":"","loc":"proc/tdm_get_tdm_pseudo_q.html"},{"title":"tdm_get_tdm_wav – NAMD Luminescense","text":"public function tdm_get_tdm_wav(wav, ispin, ikpoint, iniband, finband) result(tdm_ret) Arguments Type Intent Optional Attributes Name type( wavecar ), intent(in) :: wav integer, intent(in) :: ispin integer, intent(in) :: ikpoint integer, intent(in) :: iniband integer, intent(in) :: finband Return Value complex(kind=q)(3) local variables Contents None","tags":"","loc":"proc/tdm_get_tdm_wav.html"},{"title":"tdm_get_tdm_pseudo – NAMD Luminescense","text":"public interface tdm_get_tdm_pseudo Contents Module Procedures tdm_get_tdm_pseudo_qs tdm_get_tdm_pseudo_q tdm_get_tdm_wav Module Procedures public function tdm_get_tdm_pseudo_qs (phi_i, phi_j, k, de, wavetype) result(ret) Arguments Type Intent Optional Attributes Name complex(kind=qs), intent(in) :: phi_i (:) complex(kind=qs), intent(in) :: phi_j (:) real(kind=q), intent(in) :: k (:,:) real(kind=q), intent(in) :: de character, intent(in) :: wavetype Return Value complex(kind=q)(3) local variables public function tdm_get_tdm_pseudo_q (phi_i, phi_j, k, de, wavetype) result(ret) phi_j(n)' * phi_i(n) Arguments Type Intent Optional Attributes Name complex(kind=q), intent(in) :: phi_i (:) complex(kind=q), intent(in) :: phi_j (:) real(kind=q), intent(in) :: k (:,:) real(kind=q), intent(in) :: de character, intent(in) :: wavetype Return Value complex(kind=q)(3) local variables public function tdm_get_tdm_wav (wav, ispin, ikpoint, iniband, finband) result(tdm_ret) Arguments Type Intent Optional Attributes Name type( wavecar ), intent(in) :: wav integer, intent(in) :: ispin integer, intent(in) :: ikpoint integer, intent(in) :: iniband integer, intent(in) :: finband Return Value complex(kind=q)(3) local variables","tags":"","loc":"interface/tdm_get_tdm_pseudo.html"},{"title":"surface_hopping_hopping_destination – NAMD Luminescense","text":"public function surface_hopping_hopping_destination(sh_prob_cum) result(des) Arguments Type Intent Optional Attributes Name real(kind=q), intent(in) :: sh_prob_cum (:) Return Value integer local variables Contents None","tags":"","loc":"proc/surface_hopping_hopping_destination.html"},{"title":"surface_hopping_init – NAMD Luminescense","text":"public subroutine surface_hopping_init(sh, hamil, propmethod, shmethod, ntraj) Arguments Type Intent Optional Attributes Name type( surface_hopping ), intent(inout) :: sh type(hamiltonian), intent(in) :: hamil character(len=*), intent(in) :: propmethod character(len=*), intent(in) :: shmethod integer, intent(in) :: ntraj logic starts Contents None","tags":"","loc":"proc/surface_hopping_init.html"},{"title":"surface_hopping_init_with_input – NAMD Luminescense","text":"public subroutine surface_hopping_init_with_input(sh, hamil, inp) Arguments Type Intent Optional Attributes Name type( surface_hopping ), intent(inout) :: sh type(hamiltonian), intent(in) :: hamil type(input), intent(in) :: inp Contents None","tags":"","loc":"proc/surface_hopping_init_with_input.html"},{"title":"surface_hopping_destroy – NAMD Luminescense","text":"public subroutine surface_hopping_destroy(sh) Arguments Type Intent Optional Attributes Name type( surface_hopping ), intent(inout) :: sh Contents None","tags":"","loc":"proc/surface_hopping_destroy.html"},{"title":"surface_hopping_run – NAMD Luminescense","text":"public subroutine surface_hopping_run(sh, hamil, irank) Arguments Type Intent Optional Attributes Name type( surface_hopping ), intent(inout) :: sh type(hamiltonian), intent(inout) :: hamil integer, intent(in) :: irank local variables Contents None","tags":"","loc":"proc/surface_hopping_run.html"},{"title":"surface_hopping_run_mpi – NAMD Luminescense","text":"public subroutine surface_hopping_run_mpi(nac_dat, inp) Uses input_mod nac_mod mpi Arguments Type Intent Optional Attributes Name type(nac), intent(in) :: nac_dat type( input ), intent(in) :: inp local variables Contents None","tags":"","loc":"proc/surface_hopping_run_mpi.html"},{"title":"surface_hopping_calc_hop_prob – NAMD Luminescense","text":"public subroutine surface_hopping_calc_hop_prob(sh, hamil, iion, istate) Hopping probability\nP_{jk} = \\max[\\frac{2 \\int_t&#94;{t+\\Delta t} Re(\\rho_{jk} d_{jk}) dt}{\\rho_{jj}}, 0]\nP_jk = max(P_jk_, 0) Arguments Type Intent Optional Attributes Name type( surface_hopping ), intent(inout) :: sh type(hamiltonian), intent(in) :: hamil integer, intent(in) :: iion integer, intent(in) :: istate local variables Contents None","tags":"","loc":"proc/surface_hopping_calc_hop_prob.html"},{"title":"surface_hopping_save_to_h5 – NAMD Luminescense","text":"public subroutine surface_hopping_save_to_h5(sh, hamil, ndigit, irank, llog) Uses hdf5 propagation\ntime indices\nevolution of system's energy\npsi_t\nreal part\nimag part\nsurface hopping\ntime indices\nevolution of system's energy\nsh_pops Arguments Type Intent Optional Attributes Name type( surface_hopping ), intent(in) :: sh type(hamiltonian), intent(in) :: hamil integer, intent(in) :: ndigit integer, intent(in) :: irank logical, optional :: llog local variables Contents None","tags":"","loc":"proc/surface_hopping_save_to_h5.html"},{"title":"surface_hopping_print_stat – NAMD Luminescense","text":"public subroutine surface_hopping_print_stat(hamil, time, irank) Arguments Type Intent Optional Attributes Name type(hamiltonian), intent(in) :: hamil real(kind=q), intent(in) :: time integer, intent(in) :: irank Contents None","tags":"","loc":"proc/surface_hopping_print_stat.html"},{"title":"sh_dish_dephasetime_ – NAMD Luminescense","text":"public subroutine sh_dish_dephasetime_() Arguments None Contents None","tags":"","loc":"proc/sh_dish_dephasetime_.html"},{"title":"sh_dish_decoherence_rate_ – NAMD Luminescense","text":"public subroutine sh_dish_decoherence_rate_() Arguments None Contents None","tags":"","loc":"proc/sh_dish_decoherence_rate_.html"},{"title":"wavecar_mod – NAMD Luminescense","text":"Auxiliray functions Calculate the inverse matrix\nGenerate gvectors for each kpoint Uses common_mod string_mod Contents Interfaces wavecar_read_wavefunction Derived Types wavecar Functions wavecar_m33det_ Subroutines wavecar_init wavecar_destroy wavecar_read_wavefunction_qs wavecar_read_wavefunction_q wavecar_get_gvecs_cart wavecar_acell2bcell_ wavecar_gen_gvecs_all_k_ wavecar_gen_gvecs_single_k_ wavecar_gen_fft_freq_ Interfaces public interface wavecar_read_wavefunction public subroutine wavecar_read_wavefunction_q (wav, ispin, ikpoint, iband, phi, lnorm) Arguments Type Intent Optional Attributes Name type( wavecar ), intent(in) :: wav integer, intent(in) :: ispin integer, intent(in) :: ikpoint integer, intent(in) :: iband complex(kind=q), intent(out) :: phi (wav%nplws(ikpoint)) logical, optional :: lnorm local variables public subroutine wavecar_read_wavefunction_qs (wav, ispin, ikpoint, iband, phi, lnorm) Arguments Type Intent Optional Attributes Name type( wavecar ), intent(in) :: wav integer, intent(in) :: ispin integer, intent(in) :: ikpoint integer, intent(in) :: iband complex(kind=qs), intent(out) :: phi (wav%nplws(ikpoint)) logical, optional :: lnorm local variables Derived Types type, public :: wavecar Components Type Visibility Attributes Name Initial integer, public :: iu integer, public :: filelen integer, public :: reclen integer, public :: prec integer, public :: nspin integer, public :: nkpoints integer, public :: nbands real(kind=q), public :: encut real(kind=q), public :: efermi real(kind=q), public :: acell (3,3) real(kind=q), public :: bcell (3,3) real(kind=q), public :: volume integer, public :: ngrid (3) character(len=8), public :: wavetype integer, public, ALLOCATABLE :: gvecs (:,:,:) integer, public, ALLOCATABLE :: nplws (:) real(kind=q), public, ALLOCATABLE :: kvecs (:,:) real(kind=q), public, ALLOCATABLE :: eigs (:,:,:) real(kind=q), public, ALLOCATABLE :: fweights (:,:,:) Functions public function wavecar_m33det_ (acell) Arguments Type Intent Optional Attributes Name real(kind=q), intent(in) :: acell (3,3) Return Value real(kind=q) Subroutines public subroutine wavecar_init (wav, fname, wavetype, iu0, lgvecs) Arguments Type Intent Optional Attributes Name type( wavecar ), intent(out) :: wav character(len=*), intent(in) :: fname character(len=*), intent(in) :: wavetype integer, intent(in), optional :: iu0 logical, intent(in), optional :: lgvecs local variables public subroutine wavecar_destroy (wav) Arguments Type Intent Optional Attributes Name type( wavecar ), intent(inout) :: wav public subroutine wavecar_read_wavefunction_qs (wav, ispin, ikpoint, iband, phi, lnorm) Arguments Type Intent Optional Attributes Name type( wavecar ), intent(in) :: wav integer, intent(in) :: ispin integer, intent(in) :: ikpoint integer, intent(in) :: iband complex(kind=qs), intent(out) :: phi (wav%nplws(ikpoint)) logical, optional :: lnorm local variables public subroutine wavecar_read_wavefunction_q (wav, ispin, ikpoint, iband, phi, lnorm) Arguments Type Intent Optional Attributes Name type( wavecar ), intent(in) :: wav integer, intent(in) :: ispin integer, intent(in) :: ikpoint integer, intent(in) :: iband complex(kind=q), intent(out) :: phi (wav%nplws(ikpoint)) logical, optional :: lnorm local variables public subroutine wavecar_get_gvecs_cart (wav, ikpoint, gvecs_cart) Arguments Type Intent Optional Attributes Name type( wavecar ), intent(in) :: wav integer, intent(in) :: ikpoint real(kind=q), intent(out) :: gvecs_cart (:,:) local variables public subroutine wavecar_acell2bcell_ (A, B) Arguments Type Intent Optional Attributes Name real(kind=q), intent(in) :: A (3,3) real(kind=q), intent(out) :: B (3,3) local variables public subroutine wavecar_gen_gvecs_all_k_ (wav) Arguments Type Intent Optional Attributes Name type( wavecar ), intent(inout) :: wav local variables public subroutine wavecar_gen_gvecs_single_k_ (bcell, kvec, ngrid, encut, ngvec, wavetype, gvec) Filtering the gvectors for gamma-only version Arguments Type Intent Optional Attributes Name real(kind=q), intent(in) :: bcell (3,3) real(kind=q), intent(in) :: kvec (3) integer, intent(in) :: ngrid (3) real(kind=q), intent(in) :: encut integer, intent(in) :: ngvec character(len=*), intent(in) :: wavetype integer, intent(inout) :: gvec (:,:) local variables public subroutine wavecar_gen_fft_freq_ (ng, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ng integer, intent(out) :: g (:) local variable","tags":"","loc":"module/wavecar_mod.html"},{"title":"input_mod – NAMD Luminescense","text":"Auxiliary subroutine Uses common_mod string_mod Contents Derived Types input Subroutines input_from_file input_to_file input_destroy input_example input_mpisync Derived Types type, public :: input Components Type Visibility Attributes Name Initial character(len=256), public :: rundir = \"../run\" the directory where '0001' '0001' lies in character(len=8), public :: wavetype = \"std\" WAVECAR type, should be 'std' 'gamx' 'gamz' or 'ncl' integer, public :: ikpoint = 1 kpoint index, counts from 1 integer, public :: brange (2) = [0, 0] band index range for NAC calculation, counts from 1 integer, public :: basis_up (2) = [0, 0] basis range for spin up integer, public :: basis_dn (2) = [0, 0] basis range for spin down integer, public :: nsw = 0 NSW integer, public :: ndigit = 4 the number of digits for each step index. 4 for '0001', 5 for '00001' integer, public :: namdtime = 1000 number of steps performed by NAMD real(kind=q), public :: dt = 1.0 time step, in fs integer, public :: nsample = 100 number of samplings from total trajectory integer, public :: ntraj = 10000 number of hopping samples\nthe method used for propagation, available: \"FINITE-DIFFERENCE\", \"EXACT\", \"LIOUVILLE-TROTTER\" character(len=32), public :: propmethod = \"EXACT\" the method used for surface hopping, available: \"FSSH\" character(len=32), public :: shmethod = \"FSSH\" electronic steps for each ionic steps in propagation, different propmethod corresponds different nelms\nwe suggest: \"FINITE-DIFFERENCE\"=>1000, \"EXACT\"=>1, \"LIOUVILLE-TROTTER\"=>1 integer, public :: nelm = 1 logical, public :: lreal = .FALSE. Use real NAC or not character(len=256), public :: fname = \"NAC.h5\" file name for saving NAC data real(kind=q), public :: temperature = 300.0 NAMD temperature, in Kelvin real(kind=q), public :: scissor = 0.0 Value for scissor operator, in eV Read more… integer, public, ALLOCATABLE :: inibands (:) integer, public, ALLOCATABLE :: inispins (:) integer, public, ALLOCATABLE :: inisteps (:) For EFIELD real(kind=q), public, ALLOCATABLE :: efield (:,:) External electric field, [3, namdtime], in V/Angstrom Subroutines public subroutine input_from_file (inp, fname, llog) Arguments Type Intent Optional Attributes Name type( input ), intent(out) :: inp character, intent(in), optional :: fname logical, intent(in), optional :: llog public subroutine input_to_file (inp, fname) Arguments Type Intent Optional Attributes Name type( input ), intent(in) :: inp character, intent(in), optional :: fname public subroutine input_destroy (inp) Arguments Type Intent Optional Attributes Name type( input ), intent(inout) :: inp public subroutine input_example (nsw, nsample, fname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nsw integer, intent(in) :: nsample character, intent(in) :: fname local variables public subroutine input_mpisync (inp) Arguments Type Intent Optional Attributes Name type( input ), intent(inout) :: inp","tags":"","loc":"module/input_mod.html"},{"title":"common_mod – NAMD Luminescense","text":"Define the precisions and constants.\n@author Linjie Chen, Qijing Zheng.\nprecisions\nlower_bound interface, using binary search algorithm\nversion info Contents Variables q qs EPS IMGUNIT CPLXZERO CPLXONE HBAR AUTOA RYTOEV CLIGHT EVTOJ AMTOKG BOLKEV BOLK EVTOKCAL PI TPI FELECT EDEPS HSQDTM CITPI MAGMOMTOENERGY AUTOA2 AUTOA3 AUTOA4 AUTOA5 AUTODEBYE DEBYE2VPA FNAMELEN STDIN STDOUT STDERR NEWLINE ERROR_WAVE_OPEN_FAILED ERROR_WAVE_INVALID_PREC ERROR_WAVE_INVALID_FILE ERROR_WAVE_ALREADY_OPEN ERROR_WAVE_WAVETYPE ERROR_WAVE_NOT_OPEN ERROR_WAVE_WRONG_PREC ERROR_WAVE_WRONG_KPOINT ERROR_WAVE_WRONG_SHAPE ERROR_WAVE_WRONG_INDEX ERROR_TDM_LEN_NOT_EQUAL ERROR_NAC_WAVE_NREADY ERROR_NAC_BRANGEERROR ERROR_NAC_INCONSISTENT ERROR_INPUT_OPEN_FAILED ERROR_INPUT_EXAMPLEERR ERROR_INPUT_RANGEWRONG ERROR_INPUT_DTWRONG ERROR_INPUT_METHODERR ERROR_HAMIL_TINDEXWRONG ERROR_HAMIL_DTWRONG ERROR_HAMIL_NELMWRONG ERROR_HAMIL_RANGEWRONG ERROR_HAMIL_BASISSHORT ERROR_HAMIL_PROPMETHOD ERROR_HAMIL_DIAGFAIL ERROR_HAMIL_PROPFAIL ERROR_HAMIL_TEMPWRONG ERROR_SURFHOP_METHOD ERROR_NRANKGTNSAMPLE ERROR_FIT_FAILED MPI_ROOT_NODE Interfaces cumsum lower_bound Derived Types version Functions randint_range Subroutines version_print mpi_partition init_random_seed qsort_i qsort_partition_ cumtrapz self_correlate_function Variables Type Visibility Attributes Name Initial integer, public, parameter :: q = SELECTED_REAL_KIND(10) integer, public, parameter :: qs = SELECTED_REAL_KIND(5) real(kind=q), public, parameter :: EPS = 1.0d-10 Float number difference tolerance,\nmay be useful in float number comparisions. Some constants complex(kind=q), public, parameter :: IMGUNIT = (0.0_q, 1.0_q) complex(kind=q), public, parameter :: CPLXZERO = (0.0_q, 0.0_q) complex(kind=q), public, parameter :: CPLXONE = (1.0_q, 0.0_q) real(kind=q), public, parameter :: HBAR = 0.6582119281559802_q Important parameters, convenient for unit conversion. real(kind=q), public, parameter :: AUTOA = 0.529177249_q real(kind=q), public, parameter :: RYTOEV = 13.605826_q real(kind=q), public, parameter :: CLIGHT = 137.037_q real(kind=q), public, parameter :: EVTOJ = 1.60217733E-19_q real(kind=q), public, parameter :: AMTOKG = 1.6605402E-27_q real(kind=q), public, parameter :: BOLKEV = 8.6173857E-5_q real(kind=q), public, parameter :: BOLK = BOLKEV*EVTOJ real(kind=q), public, parameter :: EVTOKCAL = 23.06 real(kind=q), public, parameter :: PI = 3.141592653589793238_q real(kind=q), public, parameter :: TPI = 2*PI real(kind=q), public, parameter :: FELECT = 2*AUTOA*RYTOEV real(kind=q), public, parameter :: EDEPS = 4*PI*2*RYTOEV*AUTOA real(kind=q), public, parameter :: HSQDTM = RYTOEV*AUTOA*AUTOA complex(kind=q), public, parameter :: CITPI = TPI*IMGUNIT real(kind=q), public, parameter :: MAGMOMTOENERGY = 1/CLIGHT**2*AUTOA**3*RYTOEV Vector field \\f$\\mathbf{A}\\f$ times momentum times \\f$ \\frac{e}{2m_ec} \\f$\nis energy. magnetic moments are supplied in Bohr magnetons\n\\f[ \\f]\nConversion factor from magnetic moment to energy Dimensionless params real(kind=q), public, parameter :: AUTOA2 = AUTOA*AUTOA real(kind=q), public, parameter :: AUTOA3 = AUTOA*AUTOA2 real(kind=q), public, parameter :: AUTOA4 = AUTOA2*AUTOA2 real(kind=q), public, parameter :: AUTOA5 = AUTOA2*AUTOA3 real(kind=q), public, parameter :: AUTODEBYE = 2.541746 real(kind=q), public, parameter :: DEBYE2VPA = 0.2081943 integer, public, parameter :: FNAMELEN = 256 Standard input, output units integer, public, parameter :: STDIN = 5 integer, public, parameter :: STDOUT = 6 integer, public, parameter :: STDERR = 0 Newline character character, public, parameter :: NEWLINE = ACHAR(10) Error codes integer, public, parameter :: ERROR_WAVE_OPEN_FAILED = 11 integer, public, parameter :: ERROR_WAVE_INVALID_PREC = 12 integer, public, parameter :: ERROR_WAVE_INVALID_FILE = 13 integer, public, parameter :: ERROR_WAVE_ALREADY_OPEN = 14 integer, public, parameter :: ERROR_WAVE_WAVETYPE = 15 integer, public, parameter :: ERROR_WAVE_NOT_OPEN = 16 integer, public, parameter :: ERROR_WAVE_WRONG_PREC = 17 integer, public, parameter :: ERROR_WAVE_WRONG_KPOINT = 18 integer, public, parameter :: ERROR_WAVE_WRONG_SHAPE = 19 integer, public, parameter :: ERROR_WAVE_WRONG_INDEX = 20 integer, public, parameter :: ERROR_TDM_LEN_NOT_EQUAL = 40 integer, public, parameter :: ERROR_NAC_WAVE_NREADY = 50 integer, public, parameter :: ERROR_NAC_BRANGEERROR = 51 integer, public, parameter :: ERROR_NAC_INCONSISTENT = 52 integer, public, parameter :: ERROR_INPUT_OPEN_FAILED = 60 integer, public, parameter :: ERROR_INPUT_EXAMPLEERR = 61 integer, public, parameter :: ERROR_INPUT_RANGEWRONG = 62 integer, public, parameter :: ERROR_INPUT_DTWRONG = 63 integer, public, parameter :: ERROR_INPUT_METHODERR = 64 integer, public, parameter :: ERROR_HAMIL_TINDEXWRONG = 70 integer, public, parameter :: ERROR_HAMIL_DTWRONG = 71 integer, public, parameter :: ERROR_HAMIL_NELMWRONG = 72 integer, public, parameter :: ERROR_HAMIL_RANGEWRONG = 73 integer, public, parameter :: ERROR_HAMIL_BASISSHORT = 74 integer, public, parameter :: ERROR_HAMIL_PROPMETHOD = 75 integer, public, parameter :: ERROR_HAMIL_DIAGFAIL = 76 integer, public, parameter :: ERROR_HAMIL_PROPFAIL = 77 integer, public, parameter :: ERROR_HAMIL_TEMPWRONG = 78 integer, public, parameter :: ERROR_SURFHOP_METHOD = 90 integer, public, parameter :: ERROR_NRANKGTNSAMPLE = 100 integer, public, parameter :: ERROR_FIT_FAILED = 110 MPI related stuff integer, public, parameter :: MPI_ROOT_NODE = 0 cumulative sum interface Interfaces public interface cumsum private pure subroutine cumsum_i(a, b) Arguments Type Intent Optional Attributes Name integer, intent(in) :: a (:) integer, intent(out) :: b (SIZE(a)) private pure subroutine cumsum_f(a, b) Arguments Type Intent Optional Attributes Name real(kind=q), intent(in) :: a (:) real(kind=q), intent(out) :: b (SIZE(a)) public interface lower_bound private pure function lower_bound_f(A, val) result(ret) Arguments Type Intent Optional Attributes Name real(kind=q), intent(in) :: A (:) real(kind=q), intent(in) :: val Return Value integer local variables Derived Types type, public :: version Components Type Visibility Attributes Name Initial integer, public :: major integer, public :: minor integer, public :: patch character(len=32), public :: datetime character(len=64), public :: commit Functions public function randint_range (low, high) result(ret) Generate uniformly distributed random integer in closed interval [low, high] Arguments Type Intent Optional Attributes Name integer, intent(in) :: low integer, intent(in) :: high Return Value integer Subroutines public subroutine version_print (ver, io, str) Arguments Type Intent Optional Attributes Name type( version ), intent(in) :: ver integer, intent(in), optional :: io character, intent(inout), optional :: str public pure subroutine mpi_partition (nrank, length, sendcounts, displs) Partition the indices\nPlease make sure the nrank <= length, or the sendcounts[i] contains 0, which may cause fatal error with MPI\nDeal with indivisible length\ncumulative sum Arguments Type Intent Optional Attributes Name integer, intent(in) :: nrank integer, intent(in) :: length integer, intent(out) :: sendcounts (nrank) integer, intent(out) :: displs (nrank) local variables public subroutine init_random_seed () Initialize the random seed, https://gcc.gnu.org/onlinedocs/gcc-4.4.7/gfortran/RANDOM_005fSEED.html Arguments None public recursive subroutine qsort_i (A) Sort integer array in ascending order Arguments Type Intent Optional Attributes Name integer, intent(inout) :: A (:) public subroutine qsort_partition_ (A, p) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: A (:) integer, intent(inout) :: p public subroutine cumtrapz (ys, dx, ret) Arguments Type Intent Optional Attributes Name real(kind=q), intent(in) :: ys (:) real(kind=q), intent(in) :: dx real(kind=q), intent(out) :: ret (:) public subroutine self_correlate_function (a, ret) Arguments Type Intent Optional Attributes Name real(kind=q), intent(in) :: a (:) size(a) = n real(kind=q), intent(out) :: ret (:) size(ret) = n-1","tags":"","loc":"module/common_mod.html"},{"title":"string_mod – NAMD Luminescense","text":"Contents Functions int2str real2str generate_static_calculation_path toupper tolower Functions public recursive function int2str (x, fmt, ndigit) result(ret) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x character, intent(in), optional :: fmt integer, intent(in), optional :: ndigit Return Value character(len=32) public function real2str (x, fmt) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x character, intent(in), optional :: fmt Return Value character(len=32) public function generate_static_calculation_path (rundir, idx, ndigit) result(ret) Arguments Type Intent Optional Attributes Name character, intent(in) :: rundir integer, intent(in) :: idx integer, intent(in) :: ndigit Return Value character(len=256) public pure function toupper (str) result(ret) Arguments Type Intent Optional Attributes Name character, intent(in) :: str Return Value character(len=LEN) public pure function tolower (str) result(ret) Arguments Type Intent Optional Attributes Name character, intent(in) :: str Return Value character(len=LEN)","tags":"","loc":"module/string_mod.html"},{"title":"tdm_mod – NAMD Luminescense","text":"Uses string_mod common_mod wavecar_mod Contents Interfaces tdm_get_tdm_pseudo Functions tdm_get_tdm_pseudo_qs tdm_get_tdm_pseudo_q tdm_get_tdm_wav Interfaces public interface tdm_get_tdm_pseudo public function tdm_get_tdm_pseudo_qs (phi_i, phi_j, k, de, wavetype) result(ret) Arguments Type Intent Optional Attributes Name complex(kind=qs), intent(in) :: phi_i (:) complex(kind=qs), intent(in) :: phi_j (:) real(kind=q), intent(in) :: k (:,:) real(kind=q), intent(in) :: de character, intent(in) :: wavetype Return Value complex(kind=q)(3) local variables public function tdm_get_tdm_pseudo_q (phi_i, phi_j, k, de, wavetype) result(ret) phi_j(n)' * phi_i(n) Arguments Type Intent Optional Attributes Name complex(kind=q), intent(in) :: phi_i (:) complex(kind=q), intent(in) :: phi_j (:) real(kind=q), intent(in) :: k (:,:) real(kind=q), intent(in) :: de character, intent(in) :: wavetype Return Value complex(kind=q)(3) local variables public function tdm_get_tdm_wav (wav, ispin, ikpoint, iniband, finband) result(tdm_ret) Arguments Type Intent Optional Attributes Name type( wavecar ), intent(in) :: wav integer, intent(in) :: ispin integer, intent(in) :: ikpoint integer, intent(in) :: iniband integer, intent(in) :: finband Return Value complex(kind=q)(3) local variables Functions public function tdm_get_tdm_pseudo_qs (phi_i, phi_j, k, de, wavetype) result(ret) Arguments Type Intent Optional Attributes Name complex(kind=qs), intent(in) :: phi_i (:) complex(kind=qs), intent(in) :: phi_j (:) real(kind=q), intent(in) :: k (:,:) real(kind=q), intent(in) :: de character, intent(in) :: wavetype Return Value complex(kind=q)(3) local variables public function tdm_get_tdm_pseudo_q (phi_i, phi_j, k, de, wavetype) result(ret) phi_j(n)' * phi_i(n) Arguments Type Intent Optional Attributes Name complex(kind=q), intent(in) :: phi_i (:) complex(kind=q), intent(in) :: phi_j (:) real(kind=q), intent(in) :: k (:,:) real(kind=q), intent(in) :: de character, intent(in) :: wavetype Return Value complex(kind=q)(3) local variables public function tdm_get_tdm_wav (wav, ispin, ikpoint, iniband, finband) result(tdm_ret) Arguments Type Intent Optional Attributes Name type( wavecar ), intent(in) :: wav integer, intent(in) :: ispin integer, intent(in) :: ikpoint integer, intent(in) :: iniband integer, intent(in) :: finband Return Value complex(kind=q)(3) local variables","tags":"","loc":"module/tdm_mod.html"},{"title":"namd_lumi_mod – NAMD Luminescense","text":"Uses nac_mod input_mod common_mod string_mod hamiltonian_mod tdm_mod surface_hopping_mod wavecar_mod Contents None","tags":"","loc":"module/namd_lumi_mod.html"},{"title":"surface_hopping_mod – NAMD Luminescense","text":"private subroutines Uses hamiltonian_mod common_mod string_mod Contents Derived Types surface_hopping Functions surface_hopping_hopping_destination Subroutines surface_hopping_init surface_hopping_init_with_input surface_hopping_destroy surface_hopping_run surface_hopping_run_mpi surface_hopping_calc_hop_prob surface_hopping_save_to_h5 surface_hopping_print_stat sh_dish_dephasetime_ sh_dish_decoherence_rate_ Derived Types type, public :: surface_hopping Components Type Visibility Attributes Name Initial character(len=32), public :: shmethod character(len=32), public :: propmethod integer, public :: ntraj real(kind=q), public, ALLOCATABLE :: sh_prob (:,:,:) real(kind=q), public, ALLOCATABLE :: sh_pops (:,:) real(kind=q), public, ALLOCATABLE :: sh_eigs (:) Functions public function surface_hopping_hopping_destination (sh_prob_cum) result(des) Arguments Type Intent Optional Attributes Name real(kind=q), intent(in) :: sh_prob_cum (:) Return Value integer local variables Subroutines public subroutine surface_hopping_init (sh, hamil, propmethod, shmethod, ntraj) Arguments Type Intent Optional Attributes Name type( surface_hopping ), intent(inout) :: sh type(hamiltonian), intent(in) :: hamil character(len=*), intent(in) :: propmethod character(len=*), intent(in) :: shmethod integer, intent(in) :: ntraj logic starts public subroutine surface_hopping_init_with_input (sh, hamil, inp) Arguments Type Intent Optional Attributes Name type( surface_hopping ), intent(inout) :: sh type(hamiltonian), intent(in) :: hamil type(input), intent(in) :: inp public subroutine surface_hopping_destroy (sh) Arguments Type Intent Optional Attributes Name type( surface_hopping ), intent(inout) :: sh public subroutine surface_hopping_run (sh, hamil, irank) Arguments Type Intent Optional Attributes Name type( surface_hopping ), intent(inout) :: sh type(hamiltonian), intent(inout) :: hamil integer, intent(in) :: irank local variables public subroutine surface_hopping_run_mpi (nac_dat, inp) Arguments Type Intent Optional Attributes Name type(nac), intent(in) :: nac_dat type( input ), intent(in) :: inp local variables public subroutine surface_hopping_calc_hop_prob (sh, hamil, iion, istate) Hopping probability\nP_{jk} = \\max[\\frac{2 \\int_t&#94;{t+\\Delta t} Re(\\rho_{jk} d_{jk}) dt}{\\rho_{jj}}, 0]\nP_jk = max(P_jk_, 0) Arguments Type Intent Optional Attributes Name type( surface_hopping ), intent(inout) :: sh type(hamiltonian), intent(in) :: hamil integer, intent(in) :: iion integer, intent(in) :: istate local variables public subroutine surface_hopping_save_to_h5 (sh, hamil, ndigit, irank, llog) propagation\ntime indices\nevolution of system's energy\npsi_t\nreal part\nimag part\nsurface hopping\ntime indices\nevolution of system's energy\nsh_pops Arguments Type Intent Optional Attributes Name type( surface_hopping ), intent(in) :: sh type(hamiltonian), intent(in) :: hamil integer, intent(in) :: ndigit integer, intent(in) :: irank logical, optional :: llog local variables public subroutine surface_hopping_print_stat (hamil, time, irank) Arguments Type Intent Optional Attributes Name type(hamiltonian), intent(in) :: hamil real(kind=q), intent(in) :: time integer, intent(in) :: irank public subroutine sh_dish_dephasetime_ () Arguments None public subroutine sh_dish_decoherence_rate_ () Arguments None","tags":"","loc":"module/surface_hopping_mod.html"},{"title":"namd_lumi_x – NAMD Luminescense","text":"Uses cla common_mod namd_lumi_mod mpi For now, this file is for test only\ninput file loads here For timing\nget the NAC\nEnd of NAMD_lumi Contents Variables NAMD_VERSION irank ierr inp nac_dat timing_start timing_end timing_rate Subroutines cli_parse Variables Type Attributes Name Initial type( version ), parameter :: NAMD_VERSION = version(VER_MAJOR, VER_MINOR, VER_PATCH, __DATE__//\" \"//__TIME__, GIT_HASH) integer :: irank integer :: ierr type( input ) :: inp type(nac) :: nac_dat integer :: timing_start integer :: timing_end integer :: timing_rate Subroutines subroutine cli_parse () These three registries are required by -e or --inp-example Arguments None","tags":"","loc":"program/namd_lumi_x.html"},{"title":"wavecar.f90 – NAMD Luminescense","text":"Contents Modules wavecar_mod Source Code wavecar.f90 Source Code #include \"common.h\" MODULE wavecar_mod USE string_mod USE common_mod IMPLICIT NONE TYPE wavecar INTEGER :: iu INTEGER :: filelen INTEGER :: reclen INTEGER :: prec INTEGER :: nspin INTEGER :: nkpoints INTEGER :: nbands REAL ( q ) :: encut REAL ( q ) :: efermi REAL ( q ) :: acell ( 3 , 3 ) REAL ( q ) :: bcell ( 3 , 3 ) REAL ( q ) :: volume INTEGER :: ngrid ( 3 ) CHARACTER ( LEN = 8 ) :: wavetype INTEGER , ALLOCATABLE :: gvecs (:, :, :) INTEGER , ALLOCATABLE :: nplws (:) REAL ( q ), ALLOCATABLE :: kvecs (:, :) REAL ( q ), ALLOCATABLE :: eigs (:, :, :) REAL ( q ), ALLOCATABLE :: fweights (:, :, :) END TYPE wavecar INTERFACE wavecar_read_wavefunction PROCEDURE wavecar_read_wavefunction_q PROCEDURE wavecar_read_wavefunction_qs END INTERFACE CONTAINS SUBROUTINE wavecar_init ( wav , fname , wavetype , iu0 , lgvecs ) TYPE ( wavecar ), INTENT ( out ) :: wav CHARACTER ( LEN =* ), INTENT ( in ) :: fname CHARACTER ( LEN =* ), INTENT ( in ) :: wavetype INTEGER , OPTIONAL , INTENT ( in ) :: iu0 LOGICAL , OPTIONAL , INTENT ( in ) :: lgvecs !! local variables LOGICAL :: od INTEGER :: iu = 12 INTEGER :: ierr INTEGER :: irec INTEGER :: iprectag INTEGER :: maxnplw INTEGER :: i , j , k , n REAL ( q ) :: rreclen REAL ( q ) :: rnspin REAL ( q ) :: rprectag REAL ( q ) :: rnkpoints REAL ( q ) :: rnbands REAL ( q ) :: rnplw REAL ( q ) :: dummy IF ( PRESENT ( iu0 )) iu = iu0 wav % iu = iu SELECT CASE ( wavetype ) CASE ( \"std\" ) CONTINUE CASE ( \"gamx\" ) CONTINUE CASE ( \"gamz\" ) CONTINUE CASE ( \"ncl\" ) CONTINUE CASE DEFAULT WRITE ( STDERR , * ) 'Invalid wavetype=\"' // wavetype // '\", should be one of \"std\", \"gamx\", \"gamz\" or \"ncl\" ' // AT STOP ERROR_WAVE_WAVETYPE END SELECT wav % wavetype = wavetype INQUIRE ( iu , OPENED = od ) IF ( od ) THEN WRITE ( STDERR , * ) 'The WAVECAR is already open with IU= ' // TINT2STR ( iu ) // ' ' // AT STOP ERROR_WAVE_ALREADY_OPEN END IF OPEN ( UNIT = iu , FILE = fname , ACCESS = 'direct' , FORM = 'unformatted' , STATUS = 'unknown' , & RECL = 48 , IOSTAT = ierr , ACTION = 'read' ) IF ( ierr /= 0 ) THEN WRITE ( STDERR , * ) 'Cannot open WAVECAR=\"' // TRIM ( fname ) // '\" with IU=' // TINT2STR ( iu ) // ' ' // AT STOP ERROR_WAVE_OPEN_FAILED END IF READ ( UNIT = iu , REC = 1 , IOSTAT = ierr ) rreclen , rnspin , rprectag iprectag = NINT ( rprectag ) SELECT CASE ( iprectag ) CASE ( 45200 ) wav % prec = qs CASE ( 45210 ) WRITE ( STDOUT , * ) 'WARN: WAVECAR not single precision' wav % prec = q CASE DEFAULT WRITE ( STDERR , * ) 'Invalid precision tag in WAVECAR: ' // TINT2STR ( iprectag ) // AT STOP ERROR_WAVE_INVALID_PREC END SELECT wav % reclen = NINT ( rreclen ) wav % nspin = NINT ( rnspin ) IF ( wav % reclen <= 0 . OR . wav % nspin <= 0 ) THEN WRITE ( STDERR , * ) 'Invliad WAVECAR: RECLEN=' // TINT2STR ( wav % reclen ) // ' NSPIN=' // TINT2STR ( wav % nspin ) // ' ' // AT STOP ERROR_WAVE_INVALID_FILE END IF CLOSE ( iu ) OPEN ( UNIT = iu , FILE = fname , ACCESS = 'direct' , FORM = 'unformatted' , STATUS = 'unknown' , & RECL = wav % reclen , IOSTAT = ierr , ACTION = 'read' ) IF ( ierr /= 0 ) THEN WRITE ( STDERR , * ) 'Cannot open WAVECAR=\"' // TRIM ( fname ) // '\" with IU=' // TINT2STR ( iu ) // ' ' // AT STOP ERROR_WAVE_OPEN_FAILED END IF READ ( iu , rec = 2 ) rnkpoints , rnbands , wav % encut , (( wav % acell ( i , j ), i = 1 , 3 ), j = 1 , 3 ), wav % efermi wav % nkpoints = NINT ( rnkpoints ) wav % nbands = NINT ( rnbands ) CALL wavecar_acell2bcell_ ( wav % acell , wav % bcell ) wav % ngrid = CEILING (& SQRT ( wav % encut / RYTOEV ) / ( TPI / ( NORM2 ( wav % acell , DIM = 1 ) / AUTOA )) & ) * 2 + 1 wav % volume = wavecar_m33det_ ( wav % acell ) ALLOCATE ( wav % kvecs ( 3 , wav % nkpoints )) ALLOCATE ( wav % nplws ( wav % nkpoints )) ALLOCATE ( wav % eigs ( wav % nbands , wav % nkpoints , wav % nspin )) ALLOCATE ( wav % fweights ( wav % nbands , wav % nkpoints , wav % nspin )) irec = 2 DO i = 1 , wav % nspin DO j = 1 , wav % nkpoints irec = irec + 1 READ ( iu , rec = irec ) rnplw , ( wav % kvecs ( k , j ), k = 1 , 3 ), ( wav % eigs ( n , j , i ), dummy , wav % fweights ( n , j , i ), n = 1 , wav % nbands ) wav % nplws ( j ) = NINT ( rnplw ) irec = irec + wav % nbands ENDDO ENDDO IF ( wavetype == \"ncl\" ) THEN maxnplw = MAXVAL ( wav % nplws ) / 2 IF ( maxnplw * 2 /= MAXVAL ( wav % nplws )) THEN WRITE ( STDERR , * ) 'Invalid wavetype=' // TRIM ( wavetype ) // ' , nplw=' // TINT2STR ( MAXVAL ( wav % nplws )) & // ' cannot be devided by 2. ' // AT STOP ERROR_WAVE_WAVETYPE END IF ELSE maxnplw = MAXVAL ( wav % nplws ) END IF IF ( PRESENT ( lgvecs )) THEN IF ( lgvecs ) CALL wavecar_gen_gvecs_all_k_ ( wav ) END IF END SUBROUTINE wavecar_init SUBROUTINE wavecar_destroy ( wav ) TYPE ( wavecar ), INTENT ( inout ) :: wav IF ( ALLOCATED ( wav % kvecs )) DEALLOCATE ( wav % kvecs ) IF ( ALLOCATED ( wav % nplws )) DEALLOCATE ( wav % nplws ) IF ( ALLOCATED ( wav % eigs )) DEALLOCATE ( wav % eigs ) IF ( ALLOCATED ( wav % fweights )) DEALLOCATE ( wav % fweights ) IF ( ALLOCATED ( wav % gvecs )) DEALLOCATE ( wav % gvecs ) CLOSE ( wav % iu ) END SUBROUTINE wavecar_destroy SUBROUTINE wavecar_read_wavefunction_qs ( wav , ispin , ikpoint , iband , phi , lnorm ) TYPE ( wavecar ), INTENT ( in ) :: wav INTEGER , INTENT ( in ) :: ispin INTEGER , INTENT ( in ) :: ikpoint INTEGER , INTENT ( in ) :: iband COMPLEX ( qs ), INTENT ( out ) :: phi ( wav % nplws ( ikpoint )) LOGICAL , OPTIONAL :: lnorm !! local variables LOGICAL :: od INTEGER :: irec INTEGER :: i REAL ( qs ) :: normqs = 0.0_qs !! logic starts IF ( wav % prec /= qs ) THEN WRITE ( STDERR , * ) \"Inconsistent precision of WAVECAR=\" // TINT2STR ( wav % prec ) // \" and provided phi=\" // & TINT2STR ( qs ) // \" \" // AT STOP ERROR_WAVE_WRONG_PREC END IF INQUIRE ( wav % iu , OPENED = od ) IF (. NOT . od ) THEN WRITE ( STDERR , * ) \"WAVECAR not open \" // AT STOP ERROR_WAVE_NOT_OPEN END IF irec = 2 + ( ispin - 1 ) * ( wav % nkpoints * ( wav % nbands + 1 )) + & ( ikpoint - 1 ) * ( wav % nbands + 1 ) + & ( iband + 1 ) READ ( wav % iu , REC = irec ) ( phi ( i ), i = 1 , wav % nplws ( ikpoint )) IF ( PRESENT ( lnorm )) THEN IF ( lnorm ) THEN normqs = SQRT ( REAL ( SUM ( CONJG ( phi ) * phi ))) phi = phi / normqs END IF END IF END SUBROUTINE wavecar_read_wavefunction_qs SUBROUTINE wavecar_read_wavefunction_q ( wav , ispin , ikpoint , iband , phi , lnorm ) TYPE ( wavecar ), INTENT ( in ) :: wav INTEGER , INTENT ( in ) :: ispin INTEGER , INTENT ( in ) :: ikpoint INTEGER , INTENT ( in ) :: iband COMPLEX ( q ), INTENT ( out ) :: phi ( wav % nplws ( ikpoint )) LOGICAL , OPTIONAL :: lnorm !! local variables LOGICAL :: od INTEGER :: irec INTEGER :: i REAL ( q ) :: normq = 0.0_q !! logic starts IF ( wav % prec /= qs ) THEN WRITE ( STDERR , * ) \"Inconsistent precision of WAVECAR=\" // TINT2STR ( wav % prec ) // \" and provided phi=\" // & TINT2STR ( q ) // \" \" // AT STOP ERROR_WAVE_WRONG_PREC END IF INQUIRE ( wav % iu , OPENED = od ) IF (. NOT . od ) THEN WRITE ( STDERR , * ) \"WAVECAR not open \" // AT STOP ERROR_WAVE_NOT_OPEN END IF irec = 2 + ( ispin - 1 ) * ( wav % nkpoints * ( wav % nbands + 1 )) + & ( ikpoint - 1 ) * ( wav % nbands + 1 ) + & ( iband + 1 ) READ ( wav % iu , REC = irec ) ( phi ( i ), i = 1 , wav % nplws ( ikpoint )) IF ( PRESENT ( lnorm )) THEN IF ( lnorm ) THEN normq = SQRT ( REAL ( SUM ( CONJG ( phi ) * phi ))) phi = phi / normq END IF END IF END SUBROUTINE wavecar_read_wavefunction_q SUBROUTINE wavecar_get_gvecs_cart ( wav , ikpoint , gvecs_cart ) TYPE ( wavecar ), INTENT ( in ) :: wav INTEGER , INTENT ( in ) :: ikpoint REAL ( q ), INTENT ( out ) :: gvecs_cart (:, :) !! local variables INTEGER :: ngvec REAL ( q ) :: kvec ( 3 ) INTEGER , ALLOCATABLE :: gvecs_freq (:, :) !! logic starts IF ( ikpoint > wav % nkpoints . OR . ikpoint <= 0 ) THEN WRITE ( STDERR , * ) \"Kpoint index overflow: ikpoint=\" // TINT2STR ( ikpoint ) // \", nkpoint=\" // TINT2STR ( wav % nkpoints ) // \" \" // AT STOP ERROR_WAVE_WRONG_KPOINT END IF kvec = wav % kvecs (:, ikpoint ) ngvec = wav % nplws ( ikpoint ) IF ( wav % wavetype == \"ncl\" ) ngvec = ngvec / 2 IF ( ngvec /= SIZE ( gvecs_cart , 2 ) . OR . 3 /= SIZE ( gvecs_cart , 1 )) THEN WRITE ( STDERR , * ) \"Wrong shape of gvecs_cart passed in: (\" // TINT2STR ( SIZE ( gvecs_cart , 1 )) // \",\" // & TINT2STR ( SIZE ( gvecs_cart , 2 )) // \"), expected: (3,\" // TINT2STR ( ngvec ) // \") \" // AT STOP ERROR_WAVE_WRONG_SHAPE END IF ALLOCATE ( gvecs_freq ( 3 , ngvec )) IF (. NOT . ALLOCATED ( wav % gvecs )) THEN CALL wavecar_gen_gvecs_single_k_ ( wav % bcell , wav % kvecs (:, ikpoint ), wav % ngrid , wav % encut , ngvec , & wav % wavetype , gvecs_freq ) ELSE gvecs_freq = wav % gvecs (:, 1 : ngvec , ikpoint ) END IF gvecs_cart = TPI * MATMUL ( wav % bcell , gvecs_freq + SPREAD ( kvec , 2 , ngvec )) DEALLOCATE ( gvecs_freq ) END SUBROUTINE wavecar_get_gvecs_cart !! Auxiliray functions !! Calculate the inverse matrix SUBROUTINE wavecar_acell2bcell_ ( A , B ) REAL ( q ), INTENT ( in ) :: A ( 3 , 3 ) REAL ( q ), INTENT ( out ) :: B ( 3 , 3 ) !! local variables REAL ( q ) :: det det = wavecar_m33det_ ( A ) IF ( det <= EPS ) THEN WRITE ( STDERR , * ) \"Invalid WAVECAR: Volume of Acell = \" // TREAL2STR ( det ) WRITE ( STDERR , * ) \"Acell = \" , TRANSPOSE ( A ) WRITE ( STDERR , * ) AT STOP ERROR_WAVE_INVALID_FILE END IF B ( 1 , 1 ) = + ( A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 2 )) B ( 1 , 2 ) = - ( A ( 2 , 1 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 1 )) B ( 1 , 3 ) = + ( A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 1 )) B ( 2 , 1 ) = - ( A ( 1 , 2 ) * A ( 3 , 3 ) - A ( 1 , 3 ) * A ( 3 , 2 )) B ( 2 , 2 ) = + ( A ( 1 , 1 ) * A ( 3 , 3 ) - A ( 1 , 3 ) * A ( 3 , 1 )) B ( 2 , 3 ) = - ( A ( 1 , 1 ) * A ( 3 , 2 ) - A ( 1 , 2 ) * A ( 3 , 1 )) B ( 3 , 1 ) = + ( A ( 1 , 2 ) * A ( 2 , 3 ) - A ( 1 , 3 ) * A ( 2 , 2 )) B ( 3 , 2 ) = - ( A ( 1 , 1 ) * A ( 2 , 3 ) - A ( 1 , 3 ) * A ( 2 , 1 )) B ( 3 , 3 ) = + ( A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 )) B = B / det END SUBROUTINE wavecar_acell2bcell_ REAL ( q ) FUNCTION wavecar_m33det_ ( acell ) REAL ( q ), INTENT ( in ) :: acell ( 3 , 3 ) wavecar_m33det_ = acell ( 1 , 1 ) * acell ( 2 , 2 ) * acell ( 3 , 3 ) & - acell ( 1 , 1 ) * acell ( 2 , 3 ) * acell ( 3 , 2 ) & - acell ( 1 , 2 ) * acell ( 2 , 1 ) * acell ( 3 , 3 ) & + acell ( 1 , 2 ) * acell ( 2 , 3 ) * acell ( 3 , 1 ) & + acell ( 1 , 3 ) * acell ( 2 , 1 ) * acell ( 3 , 2 ) & - acell ( 1 , 3 ) * acell ( 2 , 2 ) * acell ( 3 , 1 ) END FUNCTION wavecar_m33det_ SUBROUTINE wavecar_gen_gvecs_all_k_ ( wav ) TYPE ( wavecar ), INTENT ( inout ) :: wav !! local variables INTEGER :: ngvec INTEGER :: maxnplw INTEGER :: i !! logic starts IF ( ALLOCATED ( wav % gvecs )) RETURN maxnplw = MAXVAL ( wav % nplws ) ALLOCATE ( wav % gvecs ( 3 , maxnplw , wav % nkpoints )) DO i = 1 , wav % nkpoints IF ( wav % wavetype == \"ncl\" ) THEN ngvec = wav % nplws ( i ) / 2 ELSE ngvec = wav % nplws ( i ) END IF CALL wavecar_gen_gvecs_single_k_ ( wav % bcell , wav % kvecs (:, i ), wav % ngrid , wav % encut , ngvec , & wav % wavetype , wav % gvecs (:, 1 : ngvec , i )) ENDDO END SUBROUTINE !! Generate gvectors for each kpoint SUBROUTINE wavecar_gen_gvecs_single_k_ ( bcell , kvec , ngrid , encut , ngvec , wavetype , gvec ) REAL ( q ), INTENT ( in ) :: bcell ( 3 , 3 ) REAL ( q ), INTENT ( in ) :: kvec ( 3 ) INTEGER , INTENT ( in ) :: ngrid ( 3 ) REAL ( q ), INTENT ( in ) :: encut INTEGER , INTENT ( in ) :: ngvec CHARACTER ( LEN =* ), INTENT ( in ) :: wavetype INTEGER , INTENT ( inout ) :: gvec (:, :) !! local variables INTEGER , ALLOCATABLE :: fxs (:), fys (:), fzs (:) REAL ( q ) :: gpk ( 3 ) REAL ( q ) :: genergy LOGICAL :: flag INTEGER :: cnt INTEGER :: ifx , ify , ifz INTEGER :: fx , fy , fz !! logic starts ALLOCATE ( fxs ( ngrid ( 1 ))) ALLOCATE ( fys ( ngrid ( 2 ))) ALLOCATE ( fzs ( ngrid ( 3 ))) CALL wavecar_gen_fft_freq_ ( ngrid ( 1 ), fxs ) CALL wavecar_gen_fft_freq_ ( ngrid ( 2 ), fys ) CALL wavecar_gen_fft_freq_ ( ngrid ( 3 ), fzs ) cnt = 0 DO ifz = 1 , ngrid ( 3 ) fz = fzs ( ifz ) DO ify = 1 , ngrid ( 2 ) fy = fys ( ify ) DO ifx = 1 , ngrid ( 1 ) fx = fxs ( ifx ) !! Filtering the gvectors for gamma-only version IF ( wavetype == \"gamx\" ) THEN flag = (( fx > 0 ) . OR . & ( fx == 0 . AND . fy > 0 ) . OR . & ( fx == 0 . AND . fy == 0 . AND . fz >= 0 )) ELSE IF ( wavetype == \"gamz\" ) THEN flag = (( fz > 0 ) . OR . & ( fz == 0 . AND . fy > 0 ) . OR . & ( fz == 0 . AND . fy == 0 . AND . fx >= 0 )) ELSE flag = . TRUE . END IF IF (. NOT . flag ) CYCLE gpk = ( / fx + kvec ( 1 ), fy + kvec ( 2 ), fz + kvec ( 3 ) / ) genergy = SUM ( ( MATMUL ( bcell , gpk )) ** 2 ) * TPI ** 2 * HSQDTM IF ( genergy < encut ) THEN cnt = cnt + 1 IF ( cnt > ngvec ) THEN WRITE ( STDERR , * ) 'Invalid wavetype=' // TRIM ( wavetype ) // ', ngvec=' & // TINT2STR ( cnt ) // ', ngvec_expect=' // TINT2STR ( ngvec ) // ' ' // AT STOP ERROR_WAVE_WAVETYPE END IF gvec (:, cnt ) = ( / fx , fy , fz / ) END IF ENDDO ENDDO ENDDO DEALLOCATE ( fxs ) DEALLOCATE ( fys ) DEALLOCATE ( fzs ) END SUBROUTINE wavecar_gen_gvecs_single_k_ SUBROUTINE wavecar_gen_fft_freq_ ( ng , g ) INTEGER , INTENT ( in ) :: ng INTEGER , INTENT ( out ) :: g (:) !! local variable INTEGER :: i g ( 1 : ng / 2 + 1 ) = ( / ( i , i = 0 , ng / 2 ) / ) g ( ng / 2 + 2 : ) = ( / ( i , i = ng / 2 + 1 - ng , - 1 ) / ) END SUBROUTINE wavecar_gen_fft_freq_ END MODULE wavecar_mod","tags":"","loc":"sourcefile/wavecar.f90.html"},{"title":"input.f90 – NAMD Luminescense","text":"Contents Modules input_mod Source Code input.f90 Source Code #include \"common.h\" MODULE input_mod USE common_mod USE string_mod IMPLICIT NONE TYPE :: input CHARACTER ( 256 ) :: rundir = \"../run\" !! the directory where '0001' '0001' lies in CHARACTER ( 8 ) :: wavetype = \"std\" !! WAVECAR type, should be 'std' 'gamx' 'gamz' or 'ncl' INTEGER :: ikpoint = 1 !! kpoint index, counts from 1 INTEGER :: brange ( 2 ) = [ 0 , 0 ] !! band index range for NAC calculation, counts from 1 INTEGER :: basis_up ( 2 ) = [ 0 , 0 ] !! basis range for spin up INTEGER :: basis_dn ( 2 ) = [ 0 , 0 ] !! basis range for spin down INTEGER :: nsw = 0 !! NSW INTEGER :: ndigit = 4 !! the number of digits for each step index. 4 for '0001', 5 for '00001' INTEGER :: namdtime = 1000 !! number of steps performed by NAMD REAL ( q ) :: dt = 1.0 !! time step, in fs INTEGER :: nsample = 100 !! number of samplings from total trajectory INTEGER :: ntraj = 10000 !! number of hopping samples !! the method used for propagation, available: \"FINITE-DIFFERENCE\", \"EXACT\", \"LIOUVILLE-TROTTER\" CHARACTER ( 32 ) :: propmethod = \"EXACT\" !! the method used for surface hopping, available: \"FSSH\" CHARACTER ( 32 ) :: shmethod = \"FSSH\" !! electronic steps for each ionic steps in propagation, different propmethod corresponds different nelms !! we suggest: \"FINITE-DIFFERENCE\"=>1000, \"EXACT\"=>1, \"LIOUVILLE-TROTTER\"=>1 INTEGER :: nelm = 1 LOGICAL :: lreal = . FALSE . !! Use real NAC or not CHARACTER ( 256 ) :: fname = \"NAC.h5\" !! file name for saving NAC data REAL ( q ) :: temperature = 30 0.0 !! NAMD temperature, in Kelvin REAL ( q ) :: scissor = 0.0 !! Value for scissor operator, in eV !! TODO !INTEGER         :: ncarrier     = 1         !! number of carriers INTEGER , ALLOCATABLE :: inibands (:) INTEGER , ALLOCATABLE :: inispins (:) INTEGER , ALLOCATABLE :: inisteps (:) !! For EFIELD REAL ( q ), ALLOCATABLE :: efield (:, :) !! External electric field, [3, namdtime], in V/Angstrom END TYPE PRIVATE :: input_from_iu_ PRIVATE :: input_to_iu_ CONTAINS SUBROUTINE input_from_file ( inp , fname , llog ) TYPE ( input ), INTENT ( out ) :: inp CHARACTER ( * ), INTENT ( in ), OPTIONAL :: fname LOGICAL , INTENT ( in ), OPTIONAL :: llog INTEGER , PARAMETER :: iu = 114 INTEGER :: ios IF ( PRESENT ( fname )) THEN IF ( PRESENT ( llog )) THEN IF ( llog ) WRITE ( STDOUT , '(\"[INFO] Reading input file from \", A, \" ...\")' ) '\"' // fname // '\"' END IF OPEN ( UNIT = iu , FILE = fname , IOSTAT = ios , STATUS = \"old\" , ACTION = \"read\" ) IF ( ios /= 0 ) THEN WRITE ( STDERR , '(\"[ERROR] Open file \", A, \" failed. \", A)' ) fname , AT STOP ERROR_INPUT_OPEN_FAILED END IF CALL input_from_iu_ ( iu , inp ) CLOSE ( iu ) ELSE IF ( PRESENT ( llog )) THEN IF ( llog ) WRITE ( STDOUT , '(\"[INFO] Reading input file from stdin ...\")' ) WRITE ( STDOUT , '(\"[INFO] Waiting for input ...\")' ) END IF CALL input_from_iu_ ( STDIN , inp ) END IF IF ( PRESENT ( llog )) THEN IF ( llog ) WRITE ( STDOUT , '(\"[INFO] Input file read successfully, with content of\", /, /)' ) IF ( llog ) CALL input_to_iu_ ( STDOUT , inp ) IF ( llog ) WRITE ( STDOUT , '(/)' ) END IF END SUBROUTINE input_from_file SUBROUTINE input_to_file ( inp , fname ) TYPE ( input ), INTENT ( in ) :: inp CHARACTER ( * ), INTENT ( in ), OPTIONAL :: fname INTEGER , PARAMETER :: iu = 114 INTEGER :: ios IF ( PRESENT ( fname )) THEN OPEN ( UNIT = iu , FILE = fname , IOSTAT = ios , STATUS = \"unknown\" , ACTION = \"write\" ) IF ( ios /= 0 ) THEN WRITE ( STDERR , '(\"[ERROR] Open file \", A, \" failed. \", A)' ) fname , AT STOP ERROR_INPUT_OPEN_FAILED END IF CALL input_to_iu_ ( iu , inp ) CLOSE ( iu ) ELSE CALL input_to_iu_ ( STDOUT , inp ) END IF END SUBROUTINE input_to_file SUBROUTINE input_destroy ( inp ) TYPE ( input ), INTENT ( inout ) :: inp IF ( ALLOCATED ( inp % inibands )) DEALLOCATE ( inp % inibands ) IF ( ALLOCATED ( inp % inispins )) DEALLOCATE ( inp % inispins ) IF ( ALLOCATED ( inp % inisteps )) DEALLOCATE ( inp % inisteps ) IF ( ALLOCATED ( inp % efield )) DEALLOCATE ( inp % efield ) END SUBROUTINE input_destroy SUBROUTINE input_example ( nsw , nsample , fname ) INTEGER , INTENT ( in ) :: nsw INTEGER , INTENT ( in ) :: nsample CHARACTER ( * ), INTENT ( in ) :: fname !! local variables TYPE ( input ) :: inp INTEGER :: i LOGICAL :: lexist INTEGER , PARAMETER :: iu = 10 !! logic starts WRITE ( STDOUT , '(\"[INFO] Generating example input file with NSW = \", I5, \", NSAMPLE = \", I5, \" ...\")' ) nsw , nsample inp % nsw = nsw inp % nsample = nsample IF ( nsw <= 10 ) THEN WRITE ( STDERR , '(\"[ERROR] NSW too small: \", I6, \" \", A)' ) nsw , AT STOP ERROR_INPUT_EXAMPLEERR END IF ALLOCATE ( inp % inibands ( nsample )) ALLOCATE ( inp % inispins ( nsample )) ALLOCATE ( inp % inisteps ( nsample )) ALLOCATE ( inp % efield ( 3 , inp % namdtime )) inp % inibands = 0 inp % inispins = 1 DO i = 1 , nsample inp % inisteps ( i ) = randint_range ( 1 , nsw - 1 ) ENDDO CALL qsort_i ( inp % inisteps ) inp % efield = 0.0 INQUIRE ( FILE = fname , EXIST = lexist ) IF ( lexist ) THEN WRITE ( STDOUT , '(\"[WARN] The file \", A, \" exists and will be OVERWRITTEN.\")' ) '\"' // fname // '\"' END IF CALL input_to_file ( inp , fname ) WRITE ( STDOUT , '(\"[INFO] The example input file saved to \", A)' ) '\"' // fname // '\"' DEALLOCATE ( inp % efield ) DEALLOCATE ( inp % inisteps ) DEALLOCATE ( inp % inispins ) DEALLOCATE ( inp % inibands ) END SUBROUTINE SUBROUTINE input_mpisync ( inp ) USE mpi TYPE ( input ), INTENT ( inout ) :: inp INTEGER :: ierr CALL MPI_BCAST ( inp % rundir , 256 , MPI_CHARACTER , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % wavetype , 8 , MPI_CHARACTER , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % ikpoint , 1 , MPI_INTEGER , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % brange , 2 , MPI_INTEGER , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % basis_up , 2 , MPI_INTEGER , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % basis_dn , 2 , MPI_INTEGER , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % nsw , 1 , MPI_INTEGER , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % ndigit , 1 , MPI_INTEGER , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % namdtime , 1 , MPI_INTEGER , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % dt , 1 , MPI_DOUBLE_PRECISION , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % nsample , 1 , MPI_INTEGER , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % ntraj , 1 , MPI_INTEGER , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % propmethod , 32 , MPI_CHARACTER , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % shmethod , 32 , MPI_CHARACTER , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % nelm , 1 , MPI_INTEGER , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % lreal , 1 , MPI_LOGICAL , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % fname , 256 , MPI_CHARACTER , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % temperature , 1 , MPI_DOUBLE_PRECISION , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % scissor , 1 , MPI_DOUBLE_PRECISION , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) IF (. NOT . ALLOCATED ( inp % inibands )) ALLOCATE ( inp % inibands ( inp % nsample )) IF (. NOT . ALLOCATED ( inp % inispins )) ALLOCATE ( inp % inispins ( inp % nsample )) IF (. NOT . ALLOCATED ( inp % inisteps )) ALLOCATE ( inp % inisteps ( inp % nsample )) IF (. NOT . ALLOCATED ( inp % efield )) ALLOCATE ( inp % efield ( 3 , inp % namdtime )) CALL MPI_BCAST ( inp % inibands , inp % nsample , MPI_INTEGER , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % inispins , inp % nsample , MPI_INTEGER , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % inisteps , inp % nsample , MPI_INTEGER , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) CALL MPI_BCAST ( inp % efield , 3 * inp % namdtime , MPI_DOUBLE_PRECISION , MPI_ROOT_NODE , MPI_COMM_WORLD , ierr ) END SUBROUTINE !! Auxiliary subroutine SUBROUTINE input_from_iu_ ( iu , inp ) INTEGER , INTENT ( in ) :: iu !! iu should be opened already TYPE ( input ), INTENT ( inout ) :: inp CHARACTER ( 256 ) :: rundir CHARACTER ( 8 ) :: wavetype INTEGER :: ikpoint INTEGER :: brange ( 2 ) INTEGER :: basis_up ( 2 ) INTEGER :: basis_dn ( 2 ) INTEGER :: nsw INTEGER :: ndigit INTEGER :: namdtime REAL ( q ) :: dt INTEGER :: nsample INTEGER :: ntraj CHARACTER ( 32 ) :: propmethod CHARACTER ( 32 ) :: shmethod INTEGER :: nelm LOGICAL :: lreal CHARACTER ( 256 ) :: fname REAL ( q ) :: temperature REAL ( q ) :: scissor INTEGER , ALLOCATABLE :: inibands (:) INTEGER , ALLOCATABLE :: inispins (:) INTEGER , ALLOCATABLE :: inisteps (:) REAL ( q ), ALLOCATABLE :: efield (:, :) NAMELIST / namdparams / rundir , & wavetype , & ikpoint , & brange , & basis_up , & basis_dn , & nsw , & ndigit , & namdtime , & dt , & nsample , & ntraj , & propmethod , & shmethod , & lreal , & nelm , & fname , & temperature , & scissor NAMELIST / inicon / inibands , & inispins , & inisteps NAMELIST / extfield / efield INTEGER :: nb ( 2 ) INTEGER :: nbrange INTEGER :: nbasis !! Default values for namdparams rundir = \"../run\" wavetype = \"std\" ikpoint = 1 brange = [ 0 , 0 ] basis_up = [ 0 , 0 ] basis_dn = [ 0 , 0 ] nsw = 0 ndigit = 4 namdtime = 1000 dt = 1.0 nsample = 100 ntraj = 10000 propmethod = \"EXACT\" shmethod = \"FSSH\" nelm = 1 lreal = . FALSE . fname = \"nac.h5\" temperature = 30 0.0 scissor = 0.0 READ ( iu , NML = namdparams ) !! Do some checking (limited, not complete) IF ( brange ( 1 ) <= 0 . OR . brange ( 1 ) >= brange ( 2 )) THEN WRITE ( STDERR , '(\"[ERROR] Invalid BRANGE: \", 2I5, \" \", A)' ) brange , AT STOP ERROR_INPUT_RANGEWRONG END IF nbrange = brange ( 2 ) - brange ( 1 ) + 1 IF ( ANY ( basis_up == 0 )) THEN nb ( 1 ) = 0 ELSE nb ( 1 ) = basis_up ( 2 ) - basis_up ( 1 ) + 1 END IF IF ( ANY ( basis_dn == 0 )) THEN nb ( 2 ) = 0 ELSE nb ( 2 ) = basis_dn ( 2 ) - basis_dn ( 1 ) + 1 END IF IF ( nb ( 1 ) /= 0 ) THEN IF ( nb ( 1 ) < 0 . OR . nb ( 1 ) > nbrange . OR . & ANY ( basis_up < brange ( 1 )) . OR . ANY ( basis_up > brange ( 2 ))) THEN WRITE ( STDERR , '(\"[ERROR] Invalid basis range: BASIS_UP = (\", 2I5, \")\")' ) basis_up WRITE ( STDERR , '(8X, \"valid range should be: (\", 2I5, \")\", 2X, A)' ) brange , AT STOP ERROR_INPUT_RANGEWRONG END IF END IF IF ( nb ( 2 ) /= 0 ) THEN IF ( nb ( 2 ) < 0 . OR . nb ( 2 ) > nbrange . OR . & ANY ( basis_dn < brange ( 1 )) . OR . ANY ( basis_dn > brange ( 2 ))) THEN WRITE ( STDERR , '(\"[ERROR] Invalid basis range: BASIS_DN = (\", 2I5, \")\")' ) basis_dn WRITE ( STDERR , '(8X, \"valid range should be: (\", 2I5, \")\", 2X, A)' ) brange , AT STOP ERROR_INPUT_RANGEWRONG END IF END IF nbasis = SUM ( nb ) IF ( nbasis <= 1 ) THEN WRITE ( STDERR , '(\"[ERROR] At least two bands are required to construct Hamiltonian, selected: \", I5, 2X, A)' ) nbasis , AT STOP ERROR_INPUT_RANGEWRONG END IF IF ( dt <= 0 ) THEN WRITE ( STDERR , '(\"[ERROR] Invalid BRANGE: \", F8.3, \" \", A)' ) dt , AT STOP ERROR_INPUT_DTWRONG END IF IF ( nsample < 1 ) THEN WRITE ( STDERR , '(\"[ERROR] Invalid NSAMPLE: \", I8, \" \", A)' ) nsample , AT STOP ERROR_INPUT_RANGEWRONG END IF IF ( ntraj < 1 ) THEN WRITE ( STDERR , '(\"[ERROR] Invalid NTRAJ: \", I8, \" \", A)' ) ntraj , AT STOP ERROR_INPUT_RANGEWRONG END IF propmethod = toupper ( propmethod ) SELECT CASE ( propmethod ) CASE ( \"FINITE-DIFFERENCE\" ) CONTINUE CASE ( \"EXACT\" ) CONTINUE CASE ( \"LIOUVILLE-TROTTER\" ) IF (. NOT . lreal ) THEN WRITE ( STDERR , '(\"[ERROR] This method requires NAC to be totally real, consider use LREAL=.TRUE. or use other PROPMETHOD\")' ) STOP ERROR_INPUT_METHODERR END IF CONTINUE CASE DEFAULT WRITE ( STDERR , '(\"[ERROR] Invalid PROPMETHOD: \", A, \", available: FINITE-DIFFERENCE, EXACT, LIOUVILLE-TROTTER \", A)' ) TRIM ( propmethod ), AT STOP ERROR_INPUT_METHODERR END SELECT shmethod = toupper ( shmethod ) SELECT CASE ( shmethod ) CASE ( \"FSSH\" ) CONTINUE CASE ( \"DCSH\" ) CONTINUE CASE ( \"DISH\" ) CONTINUE CASE DEFAULT WRITE ( STDERR , '(\"[ERROR] Invalid SHMETHOD: \", A, \", available: FSSH, DCSH, DISH \", A)' ) TRIM ( shmethod ), AT STOP ERROR_INPUT_METHODERR END SELECT IF ( temperature <= 0.0 ) THEN WRITE ( STDERR , '(\"[ERROR] Invalid TEMPERATURE from input file: \", F8.2, \" Kelvin\")' ) temperature STOP ERROR_INPUT_RANGEWRONG END IF IF ( scissor < 0.0 ) THEN WRITE ( STDERR , '(\"[ERROR] Negative SCISSOR from input file: \", F8.2, \" eV\")' ) temperature STOP ERROR_INPUT_RANGEWRONG ENDIF !! Continue to construct input data inp % rundir = rundir inp % wavetype = wavetype inp % ikpoint = ikpoint inp % brange = brange inp % basis_up = basis_up inp % basis_dn = basis_dn inp % nsw = nsw inp % ndigit = ndigit inp % namdtime = namdtime inp % dt = dt inp % nsample = nsample inp % ntraj = ntraj inp % propmethod = propmethod inp % shmethod = shmethod inp % nelm = nelm inp % lreal = lreal inp % fname = fname inp % temperature = temperature inp % scissor = scissor ALLOCATE ( inp % inibands ( nsample )) ALLOCATE ( inp % inispins ( nsample )) ALLOCATE ( inp % inisteps ( nsample )) ALLOCATE ( inibands ( nsample )) ALLOCATE ( inispins ( nsample )) ALLOCATE ( inisteps ( nsample )) READ ( iu , NML = inicon ) inp % inisteps = inisteps inp % inibands = inibands inp % inispins = inispins DEALLOCATE ( inisteps ) DEALLOCATE ( inispins ) DEALLOCATE ( inibands ) !! efield stuff ALLOCATE ( inp % efield ( 3 , namdtime )) ALLOCATE ( efield ( 3 , namdtime )) efield = 0.0 READ ( iu , NML = extfield ) inp % efield = efield DEALLOCATE ( efield ) END SUBROUTINE input_from_iu_ SUBROUTINE input_to_iu_ ( iu , inp ) INTEGER , INTENT ( in ) :: iu TYPE ( input ), INTENT ( in ) :: inp INTEGER :: i !! namdparams stuff WRITE ( iu , '(A)' ) \"&NAMDPARAMS\" ! Start WRITE ( iu , '(1X, A12, \" = \",    A, \", ! \", A)' ) 'RUNDIR' , '\"' // TRIM ( inp % rundir ) // '\"' , & 'Directory that contains \"????/WAVECAR\"' WRITE ( iu , '(1X, A12, \" = \",  A10, \", ! \", A)' ) 'WAVETYPE' , '\"' // TRIM ( inp % wavetype ) // '\"' , & 'WAVECAR type: \"std\" \"gamx\" \"gamz\" or \"ncl\"' WRITE ( iu , '(1X, A12, \" = \",  I10, \", ! \", A)' ) 'IKPOINT' , inp % ikpoint , \"Kpoint index\" WRITE ( iu , '(1X, A12, \" = \",  2I5, \", ! \", A)' ) 'BRANGE' , inp % brange , \"Band range to calculate NAC, wider than NBASIS\" WRITE ( iu , '(1X, A12, \" = \",  2I5, \", ! \", A)' ) 'BASIS_UP' , inp % basis_up , \"Spin up basis range to calculate NAC\" WRITE ( iu , '(1X, A12, \" = \",  2I5, \", ! \", A)' ) 'BASIS_DN' , inp % basis_dn , \"Spin down basis range to calculate NAC\" WRITE ( iu , '(1X, A12, \" = \",  I10, \", ! \", A)' ) 'NSW' , inp % nsw , \"Number of total trajectory steps\" WRITE ( iu , '(1X, A12, \" = \",  I10, \", ! \", A)' ) 'NDIGIT' , inp % ndigit , & \"Number of digits of trajectory index, 4 for 0001, 5 for 00001\" WRITE ( iu , '(1X, A12, \" = \",  I10, \", ! \", A)' ) 'NAMDTIME' , inp % namdtime , \"Time steps for each NAMD sample\" WRITE ( iu , '(1X, A12, \" = \",F10.2, \", ! \", A)' ) 'DT' , inp % dt , \"Time step for trajectory and NAMD, in fs\" WRITE ( iu , '(1X, A12, \" = \",  I10, \", ! \", A)' ) 'NSAMPLE' , inp % nsample , \"Number of samplings from total trajectory\" WRITE ( iu , '(1X, A12, \" = \",  I10, \", ! \", A)' ) 'NTRAJ' , inp % ntraj , \"Number of hopping samples\" WRITE ( iu , '()' ) WRITE ( iu , '(4X, A)' ) '!! the method used for propagation, available: \"FINITE-DIFFERENCE\", \"EXACT\", \"LIOUVILLE-TROTTER\"' WRITE ( iu , '(1X, A12, \" = \",    A, \",\")' ) \"PROPMETHOD\" , '\"' // TRIM ( inp % propmethod ) // '\"' WRITE ( iu , '()' ) WRITE ( iu , '(4X, A)' ) '!! electronic steps for each ionic steps in propagation, different propmethod corresponds different nelms' WRITE ( iu , '(4X, A)' ) '!! we suggest: \"FINITE-DIFFERENCE\"=>1000, \"EXACT\"=>1, \"LIOUVILLE-TROTTER\"=>1' WRITE ( iu , '(1X, A12, \" = \",  I10, \",\")' ) \"NELM\" , inp % nelm WRITE ( iu , '(1X, A12, \" = \",  L10, \", ! \", A)' ) \"LREAL\" , inp % lreal , \"Use real NAC or not\" WRITE ( iu , '()' ) WRITE ( iu , '(4X, A)' ) '!! the method used for surface hoppint, available: \"FSSH\", \"DCSH\", \"DISH\"' WRITE ( iu , '(1X, A12, \" = \",    A, \",\")' ) \"SHMETHOD\" , '\"' // TRIM ( inp % shmethod ) // '\"' WRITE ( iu , '()' ) WRITE ( iu , '(1X, A12, \" = \",    A, \", ! \", A)' ) \"FNAME\" , '\"' // TRIM ( inp % fname ) // '\"' , & \"file name for saving NAC data, no more than 256 characters\" WRITE ( iu , '(1X, A12, \" = \",F10.2, \", ! \", A)' ) 'TEMPERATURE' , inp % temperature , \"NAMD temperature, in Kelvin\" WRITE ( iu , '(1X, A12, \" = \",F10.2, \", ! \", A)' ) 'SCISSOR' , inp % scissor , \"Scissor operator, in eV\" WRITE ( iu , '(A)' ) \"/\" ! End WRITE ( iu , '(/,/)' , ADVANCE = 'no' ) ! Two empty lines !! inicon stuff WRITE ( iu , '(A)' ) \"&INICON\" ! Start WRITE ( iu , '(4X, \"!! Initial step indices for each sample, must be within [1, NSW-NAMDTIME-1].\")' ) WRITE ( iu , '(4X, \"INISTEPS(:) = \", *(I5))' ) inp % inisteps (:) WRITE ( iu , '(/)' , ADVANCE = 'no' ) WRITE ( iu , '(4X, \"!! Initial band indices for each sample, must be within the basis range.\")' ) WRITE ( iu , '(4X, \"!! If all the inibands are same, INIBANDS(:) = 8*320 is also ok, where 8 is NSAMPLE and 320 is INIBAND\")' ) WRITE ( iu , '(4X, \"INIBANDS(:) = \", *(I5))' ) inp % inibands (:) WRITE ( iu , '(/)' , ADVANCE = 'no' ) WRITE ( iu , '(4X, \"!! Initial spin indices for each sample, must be within [1, NSPIN]\")' ) WRITE ( iu , '(4X, \"!! If all the inispins are same, INISPINS(:) = 8*1 is also ok, where 8 is NSAMPLE and 1 is INISPIN\")' ) WRITE ( iu , '(4X, \"INISPINS(:) = \", *(I5))' ) inp % inispins (:) WRITE ( iu , '(A)' ) \"/\" ! End WRITE ( iu , '(/,/)' , ADVANCE = 'no' ) ! Two empty lines !! external field stuff WRITE ( iu , '(A)' ) \"&EXTFIELD\" WRITE ( iu , '(4X, A)' ) \"!! Time-dependent electric field appllied to current system, in 1E-9 V/Angstrom\" WRITE ( iu , '(4X, \"!!\", 3(4X, A7), A9)' ) \"X\" , \"Y\" , \"Z\" , \"TIMESTEP\" WRITE ( iu , '(4X, A)' ) \"EFIELD(:,:) =\" DO i = 1 , inp % namdtime WRITE ( iu , '(2X, 3(1X, D13.5), \" !\", I7)' ) inp % efield (:, i ), i ENDDO WRITE ( iu , '(A)' ) \"/\" END SUBROUTINE input_to_iu_ END MODULE","tags":"","loc":"sourcefile/input.f90.html"},{"title":"namd_lumi.f90 – NAMD Luminescense","text":"Contents Programs namd_lumi_x Source Code namd_lumi.f90 Source Code !> For now, this file is for test only PROGRAM namd_lumi_x USE common_mod USE cla USE mpi USE namd_lumi_mod IMPLICIT NONE TYPE ( version ), PARAMETER :: NAMD_VERSION = & version ( & VER_MAJOR , VER_MINOR , VER_PATCH , & __ DATE__ // \" \" // __ TIME__ , & GIT_HASH & ) INTEGER :: irank , ierr TYPE ( input ) :: inp TYPE ( nac ) :: nac_dat INTEGER :: timing_start , timing_end , timing_rate !#ifdef OPENBLAS !CALL OPENBLAS_SET_NUM_THREADS(1) !#endif CALL MPI_INIT ( ierr ) CALL MPI_COMM_RANK ( MPI_COMM_WORLD , irank , ierr ) IF ( irank == MPI_ROOT_NODE ) THEN CALL version_print ( NAMD_VERSION ) CALL cli_parse !! input file loads here IF ( inp % scissor > 0.0 ) THEN WRITE ( STDOUT , '(\"[WARN] You have specified SCISSOR > 0, thus no band crossings between VBM and CBM are required.\")' ) ENDIF WRITE ( STDOUT , '(A)' ) \"================================================================================\" WRITE ( STDOUT , '(A)' ) \"                      INPUT FILES READY, START CALCULATING                      \" WRITE ( STDOUT , '(A)' ) \"================================================================================\" ENDIF CALL MPI_BARRIER ( MPI_COMM_WORLD , ierr ) !! For timing CALL SYSTEM_CLOCK ( timing_start , timing_rate ) CALL input_mpisync ( inp ) !! get the NAC CALL nac_load_or_calculate ( nac_dat , inp ) CALL nac_mpisync ( nac_dat ) IF ( MPI_ROOT_NODE == irank ) THEN WRITE ( STDOUT , '(A)' ) \"================================================================================\" WRITE ( STDOUT , '(A)' ) \"                      NACouplings READY, START CALCULATING                      \" WRITE ( STDOUT , '(A)' ) \"================================================================================\" ENDIF CALL MPI_BARRIER ( MPI_COMM_WORLD , ierr ) CALL surface_hopping_run_mpi ( nac_dat , inp ) CALL nac_destroy ( nac_dat ) CALL MPI_BARRIER ( MPI_COMM_WORLD , ierr ) CALL SYSTEM_CLOCK ( timing_end , timing_rate ) IF ( irank == MPI_ROOT_NODE ) THEN WRITE ( STDOUT , '(A)' ) \"================================================================================\" WRITE ( STDOUT , '(A, F10.3, A)' ) \"    CONGRATULATIONS, ALL CALCULATIONS DONE IN \" , DBLE ( timing_end - timing_start ) / timing_rate , \" SECS.\" WRITE ( STDOUT , '(A)' ) \"================================================================================\" ENDIF CALL MPI_FINALIZE ( ierr ) !! End of NAMD_lumi CONTAINS SUBROUTINE cli_parse CHARACTER ( STRLEN ) :: progname !! STRLEN = 80  from cla.mod CHARACTER ( STRLEN ) :: inpname CHARACTER ( STRLEN ) :: inp_example_fname INTEGER :: inp_example_nsw INTEGER :: inp_example_nsample CALL GETARG ( 0 , progname ) CALL cla_init CALL cla_register ( key = '-i' , longkey = '--inp' , & description = 'Input file name, if left empty, this program reads input from stdin' , & kkind = cla_char , default = 'namd_lumi-input.nml' ) CALL cla_register ( key = '-e' , longkey = '--inp-example' , & description = 'Generate the example input and save it to the file you specified' , & kkind = cla_logical , default = 'F' ) !! These three registries are required by -e or --inp-example CALL cla_register ( key = '-f' , longkey = '--example-fname' , & description = 'Example input file name' , & kkind = cla_int , default = 'namd_lumi-example.nml' ) CALL cla_register ( key = '-w' , longkey = '--nsw' , & description = 'NSW for input file, only valid for generating example input' , & kkind = cla_int , default = '3000' ) CALL cla_register ( key = '-s' , longkey = '--nsample' , & description = 'NSAMPLE for input file, only valid for generating example input' , & kkind = cla_int , default = '10' ) CALL cla_validate ( TRIM ( progname )) IF ( cla_key_present ( '-e' )) THEN CALL cla_get ( '-f' , inp_example_fname ) CALL cla_get ( '-w' , inp_example_nsw ) CALL cla_get ( '-s' , inp_example_nsample ) CALL input_example ( inp_example_nsw , inp_example_nsample , TRIM ( inp_example_fname )) CALL MPI_FINALIZE ( ierr ) STOP ELSE IF ( cla_key_present ( '-i' )) THEN CALL cla_get ( '-i' , inpname ) CALL input_from_file ( inp , TRIM ( inpname ), llog = . TRUE .) ELSE CALL input_from_file ( inp , llog = . TRUE .) END IF END IF END SUBROUTINE cli_parse END PROGRAM namd_lumi_x","tags":"","loc":"sourcefile/namd_lumi.f90.html"},{"title":"common.f90 – NAMD Luminescense","text":"Contents Modules common_mod Source Code common.f90 Source Code !> Define the precisions and constants. !! @author Linjie Chen, Qijing Zheng. MODULE common_mod IMPLICIT NONE !! precisions INTEGER , PARAMETER :: q = SELECTED_REAL_KIND ( 10 ) !< Double precision indicator INTEGER , PARAMETER :: qs = SELECTED_REAL_KIND ( 5 ) !< Single precision indicator !> Float number difference tolerance, !! may be useful in float number comparisions. REAL ( q ), PARAMETER :: EPS = 1.0d-10 !! Some constants COMPLEX ( q ), PARAMETER :: IMGUNIT = ( 0.0_q , 1.0_q ) !< Imaginary unit COMPLEX ( q ), PARAMETER :: CPLXZERO = ( 0.0_q , 0.0_q ) !< Complex zero: 0.0+0.0i COMPLEX ( q ), PARAMETER :: CPLXONE = ( 1.0_q , 0.0_q ) !< Complex one: 1.0+0.0i REAL ( q ), PARAMETER :: HBAR = 0.6582119281559802_q !< ħ in eV*fs !! Important parameters, convenient for unit conversion. REAL ( q ), PARAMETER :: AUTOA = 0.529177249_q !< 1 a.u. in Å REAL ( q ), PARAMETER :: RYTOEV = 1 3.605826_q !< Rydberg constant in eV REAL ( q ), PARAMETER :: CLIGHT = 13 7.037_q !< Light speed in a.u. REAL ( q ), PARAMETER :: EVTOJ = 1.60217733E-19_q !< 1 eV in 1 Joule REAL ( q ), PARAMETER :: AMTOKG = 1.6605402E-27_q !< 1 atomic mass (proton mass) in kg REAL ( q ), PARAMETER :: BOLKEV = 8.6173857E-5_q !< Boltzmanns constant in eV/K REAL ( q ), PARAMETER :: BOLK = BOLKEV * EVTOJ !< Boltzmanns constant in Joule/K REAL ( q ), PARAMETER :: EVTOKCAL = 2 3.06 !< 1 ev in 1 kilo Calorie REAL ( q ), PARAMETER :: PI = 3.141592653589793238_q !< π constant REAL ( q ), PARAMETER :: TPI = 2 * PI !< 2π constant REAL ( q ), PARAMETER :: FELECT = 2 * AUTOA * RYTOEV !< \\f$ \\displaystyle \\frac{e}{4\\pi\\varepsilon_0} \\f$ in atomic units REAL ( q ), PARAMETER :: EDEPS = 4 * PI * 2 * RYTOEV * AUTOA !< \\f$ \\displaystyle \\frac{e}{\\varepsilon_0} \\f$ in atomic units REAL ( q ), PARAMETER :: HSQDTM = RYTOEV * AUTOA * AUTOA !< \\f$ \\displaystyle \\frac{\\hbar&#94;2}{2m_e} \\f$ COMPLEX ( q ), PARAMETER :: CITPI = TPI * IMGUNIT !< 0+3πi !> Vector field \\f$\\mathbf{A}\\f$ times momentum times \\f$ \\frac{e}{2m_ec} \\f$ !! is energy. magnetic moments are supplied in Bohr magnetons !! \\f[ !! \\begin{aligned} !!      E &={} \\frac{e}{2m_ec}A(r)p(r) \\\\ !!        &={} \\frac{e}{2m_ec}m_s \\frac{r-r_s}{(r-r_s)&#94;3} \\hbar \\nabla \\\\ !!        &={} e&#94;2 \\frac{\\hbar&#94;2}{2m_e&#94;2 c&#94;2} \\frac{1}{l&#94;3} !! \\end{aligned} !! \\f] !! Conversion factor from magnetic moment to energy REAL ( q ), PARAMETER :: MAGMOMTOENERGY = 1 / CLIGHT ** 2 * AUTOA ** 3 * RYTOEV !! Dimensionless params REAL ( q ), PARAMETER :: AUTOA2 = AUTOA * AUTOA !< AUTOA&#94;2 REAL ( q ), PARAMETER :: AUTOA3 = AUTOA * AUTOA2 !< AUTOA&#94;3 REAL ( q ), PARAMETER :: AUTOA4 = AUTOA2 * AUTOA2 !< AUTOA&#94;4 REAL ( q ), PARAMETER :: AUTOA5 = AUTOA2 * AUTOA3 !< AUTOA&#94;5 REAL ( q ), PARAMETER :: AUTODEBYE = 2.541746 !< Dipole moment in atomic units to Debye REAL ( q ), PARAMETER :: DEBYE2VPA = 0.2081943 !< 1 Debye = 0.2081943 e*Å INTEGER , PARAMETER :: FNAMELEN = 256 !< Maximum length of file name !! Standard input, output units INTEGER , PARAMETER :: STDIN = 5 INTEGER , PARAMETER :: STDOUT = 6 INTEGER , PARAMETER :: STDERR = 0 !! Newline character CHARACTER , PARAMETER :: NEWLINE = ACHAR ( 10 ) !! Error codes INTEGER , PARAMETER :: ERROR_WAVE_OPEN_FAILED = 11 INTEGER , PARAMETER :: ERROR_WAVE_INVALID_PREC = 12 INTEGER , PARAMETER :: ERROR_WAVE_INVALID_FILE = 13 INTEGER , PARAMETER :: ERROR_WAVE_ALREADY_OPEN = 14 INTEGER , PARAMETER :: ERROR_WAVE_WAVETYPE = 15 INTEGER , PARAMETER :: ERROR_WAVE_NOT_OPEN = 16 INTEGER , PARAMETER :: ERROR_WAVE_WRONG_PREC = 17 INTEGER , PARAMETER :: ERROR_WAVE_WRONG_KPOINT = 18 INTEGER , PARAMETER :: ERROR_WAVE_WRONG_SHAPE = 19 INTEGER , PARAMETER :: ERROR_WAVE_WRONG_INDEX = 20 INTEGER , PARAMETER :: ERROR_TDM_LEN_NOT_EQUAL = 40 INTEGER , PARAMETER :: ERROR_NAC_WAVE_NREADY = 50 INTEGER , PARAMETER :: ERROR_NAC_BRANGEERROR = 51 INTEGER , PARAMETER :: ERROR_NAC_INCONSISTENT = 52 INTEGER , PARAMETER :: ERROR_INPUT_OPEN_FAILED = 60 INTEGER , PARAMETER :: ERROR_INPUT_EXAMPLEERR = 61 INTEGER , PARAMETER :: ERROR_INPUT_RANGEWRONG = 62 INTEGER , PARAMETER :: ERROR_INPUT_DTWRONG = 63 INTEGER , PARAMETER :: ERROR_INPUT_METHODERR = 64 INTEGER , PARAMETER :: ERROR_HAMIL_TINDEXWRONG = 70 INTEGER , PARAMETER :: ERROR_HAMIL_DTWRONG = 71 INTEGER , PARAMETER :: ERROR_HAMIL_NELMWRONG = 72 INTEGER , PARAMETER :: ERROR_HAMIL_RANGEWRONG = 73 INTEGER , PARAMETER :: ERROR_HAMIL_BASISSHORT = 74 INTEGER , PARAMETER :: ERROR_HAMIL_PROPMETHOD = 75 INTEGER , PARAMETER :: ERROR_HAMIL_DIAGFAIL = 76 INTEGER , PARAMETER :: ERROR_HAMIL_PROPFAIL = 77 INTEGER , PARAMETER :: ERROR_HAMIL_TEMPWRONG = 78 INTEGER , PARAMETER :: ERROR_SURFHOP_METHOD = 90 INTEGER , PARAMETER :: ERROR_NRANKGTNSAMPLE = 100 INTEGER , PARAMETER :: ERROR_FIT_FAILED = 110 !! MPI related stuff INTEGER , PARAMETER :: MPI_ROOT_NODE = 0 !! cumulative sum interface INTERFACE cumsum PROCEDURE cumsum_i PROCEDURE cumsum_f END INTERFACE cumsum PRIVATE :: cumsum_i PRIVATE :: cumsum_f !! lower_bound interface, using binary search algorithm INTERFACE lower_bound PROCEDURE lower_bound_f END INTERFACE lower_bound PRIVATE :: lower_bound_f !! version info TYPE :: version INTEGER :: major INTEGER :: minor INTEGER :: patch CHARACTER ( 32 ) :: datetime !< build date and time CHARACTER ( 64 ) :: commit !< git commit hash code END TYPE version CONTAINS SUBROUTINE version_print ( ver , io , str ) TYPE ( version ), INTENT ( in ) :: ver INTEGER , INTENT ( in ), OPTIONAL :: io CHARACTER ( * ), INTENT ( inout ), OPTIONAL :: str IF ( PRESENT ( io )) THEN WRITE ( io , 100 ) ver % major , ver % minor , ver % patch , TRIM ( ver % datetime ), TRIM ( ver % commit ) ELSE IF ( PRESENT ( str )) THEN WRITE ( str , 100 ) ver % major , ver % minor , ver % patch , TRIM ( ver % datetime ), TRIM ( ver % commit ) ELSE WRITE ( STDOUT , 100 ) ver % major , ver % minor , ver % patch , TRIM ( ver % datetime ), TRIM ( ver % commit ) END IF 100 FORMAT ( \"NAMD_lumi v\" , I0 , \".\" , I0 , \".\" , I0 , \"  BuiltDateTime: \" , A , \"  GitCommit: \" , A ) END SUBROUTINE version_print ! copied from https://github.com/ivan-pi/cumsum_benchmark PURE SUBROUTINE cumsum_i ( a , b ) INTEGER , INTENT ( in ) :: a (:) INTEGER , INTENT ( out ) :: b ( SIZE ( a )) INTRINSIC :: SIZE ! local variables INTEGER :: s0 , s1 INTEGER :: x0 , x1 INTEGER :: i , n s0 = 0 s1 = 0 n = SIZE ( a ) DO i = 1 , n , 2 x0 = a ( i ) x1 = a ( i + 1 ) s0 = s1 + x0 s1 = s1 + ( x1 + x0 ) b ( i ) = s0 b ( i + 1 ) = s1 ENDDO ! if the length is odd IF ( MOD ( n , 2 ) /= 0 ) b ( n ) = b ( n - 1 ) + a ( n ) END SUBROUTINE cumsum_i ! copied from https://github.com/ivan-pi/cumsum_benchmark PURE SUBROUTINE cumsum_f ( a , b ) REAL ( q ), INTENT ( in ) :: a (:) REAL ( q ), INTENT ( out ) :: b ( SIZE ( a )) INTRINSIC :: SIZE ! local variables REAL ( q ) :: s0 , s1 REAL ( q ) :: x0 , x1 INTEGER :: i , n s0 = 0.0 s1 = 0.0 n = SIZE ( a ) DO i = 1 , n , 2 x0 = a ( i ) x1 = a ( i + 1 ) s0 = s1 + x0 s1 = s1 + ( x1 + x0 ) b ( i ) = s0 b ( i + 1 ) = s1 ENDDO ! if the length is odd IF ( MOD ( n , 2 ) /= 0 ) b ( n ) = b ( n - 1 ) + a ( n ) END SUBROUTINE cumsum_f PURE FUNCTION lower_bound_f ( A , val ) RESULT ( ret ) REAL ( q ), INTENT ( in ) :: A (:) REAL ( q ), INTENT ( in ) :: val INTEGER :: ret !! local variables INTEGER :: l , m , r INTEGER :: N N = SIZE ( A ) l = 0 r = N + 1 DO WHILE ( l + 1 /= r ) m = l + ( r - l ) / 2 IF ( A ( m ) < val ) THEN l = m ELSE r = m END IF ENDDO ret = r END FUNCTION lower_bound_f !> Partition the indices !! Please make sure the nrank <= length, or the sendcounts[i] contains 0, which may cause fatal error with MPI PURE SUBROUTINE mpi_partition ( nrank , length , sendcounts , displs ) INTEGER , INTENT ( in ) :: nrank INTEGER , INTENT ( in ) :: length INTEGER , INTENT ( out ) :: sendcounts ( nrank ) INTEGER , INTENT ( out ) :: displs ( nrank ) !! local variables INTEGER :: quotient , residue INTEGER :: i !! logic starts quotient = length / nrank residue = MOD ( length , nrank ) sendcounts = 0 displs = 0 DO i = 1 , nrank sendcounts ( i ) = quotient IF ( residue > 0 ) THEN !! Deal with indivisible length sendcounts ( i ) = sendcounts ( i ) + 1 residue = residue - 1 END IF ENDDO DO i = 2 , nrank IF ( i >= 2 ) THEN displs ( i ) = displs ( i - 1 ) + sendcounts ( i - 1 ) !! cumulative sum END IF ENDDO END SUBROUTINE mpi_partition !> Generate uniformly distributed random integer in closed interval [low, high] FUNCTION randint_range ( low , high ) RESULT ( ret ) INTEGER , INTENT ( in ) :: low , high INTEGER :: ret REAL ( q ) :: r CALL RANDOM_NUMBER ( r ) ret = FLOOR (( high - low + 1 ) * r ) + low END FUNCTION randint_range !> Initialize the random seed, https://gcc.gnu.org/onlinedocs/gcc-4.4.7/gfortran/RANDOM_005fSEED.html SUBROUTINE init_random_seed INTEGER :: i , n , clock INTEGER , DIMENSION (:), ALLOCATABLE :: seed CALL RANDOM_SEED ( size = n ) ALLOCATE ( seed ( n )) CALL SYSTEM_CLOCK ( COUNT = clock ) seed = clock + 37 * ( / ( i - 1 , i = 1 , n ) / ) CALL RANDOM_SEED ( PUT = seed ) DEALLOCATE ( seed ) END SUBROUTINE !> Sort integer array in ascending order RECURSIVE SUBROUTINE qsort_i ( A ) INTEGER , INTENT ( inout ) :: A (:) INTEGER :: len , p INTEGER :: temp len = SIZE ( A ) IF ( len <= 1 ) RETURN p = randint_range ( 1 , len ) #define SWAP(_X, _Y) temp=_X; _X=_Y; _Y=temp; SWAP ( A ( 1 ), A ( p )) #undef SWAP CALL qsort_partition_ ( A , p ) CALL qsort_i ( A (: p - 1 )) CALL qsort_i ( A ( p + 1 :)) END SUBROUTINE qsort_i SUBROUTINE qsort_partition_ ( A , p ) INTEGER , INTENT ( inout ) :: A (:) INTEGER , INTENT ( inout ) :: p INTEGER :: i , j INTEGER :: temp #define SWAP(_X, _Y) temp=_X; _X=_Y; _Y=temp; p = SIZE ( A ) i = 1 DO j = 1 , p IF ( A ( j ) < A ( p )) THEN SWAP ( A ( i ), A ( j )) i = i + 1 ENDIF ENDDO SWAP ( A ( i ), A ( p )) p = i #undef SWAP END SUBROUTINE qsort_partition_ SUBROUTINE cumtrapz ( ys , dx , ret ) REAL ( q ), INTENT ( in ) :: ys (:) ! size(ys) = n REAL ( q ), INTENT ( in ) :: dx REAL ( q ), INTENT ( out ) :: ret (:) ! size(ret) = n INTEGER :: n INTEGER :: i REAL ( q ) :: s n = SIZE ( ys ) s = 0.0_q ret = s DO i = 2 , n s = s + ys ( i - 1 ) + ys ( i ) ret ( i ) = s ENDDO ret = ret * dx / 2.0_q END SUBROUTINE cumtrapz SUBROUTINE self_correlate_function ( a , ret ) REAL ( q ), INTENT ( in ) :: a (:) !! size(a) = n REAL ( q ), INTENT ( out ) :: ret (:) !! size(ret) = n-1 INTEGER :: i INTEGER :: n !! This result is same with `np.correlate(a, a, mode='full')[a.size:]` n = SIZE ( a ) DO i = 1 , n - 1 ret ( i ) = SUM ( a ( 1 : n - i ) * a ( 1 + i : n )) ENDDO END SUBROUTINE self_correlate_function END MODULE common_mod","tags":"","loc":"sourcefile/common.f90.html"},{"title":"string.f90 – NAMD Luminescense","text":"Contents Modules string_mod Source Code string.f90 Source Code MODULE string_mod IMPLICIT NONE CONTAINS RECURSIVE FUNCTION int2str ( x , fmt , ndigit ) RESULT ( ret ) INTEGER , INTENT ( in ) :: x CHARACTER ( * ), INTENT ( in ), OPTIONAL :: fmt INTEGER , INTENT ( in ), OPTIONAL :: ndigit CHARACTER ( 32 ) :: ret CHARACTER ( 32 ) :: fmt_str IF ( PRESENT ( fmt )) THEN WRITE ( ret , fmt ) x ret = TRIM ( ADJUSTL ( ret )) ELSE IF ( PRESENT ( ndigit )) THEN fmt_str = \"(I0.\" // TRIM ( int2str ( ndigit )) // \")\" WRITE ( ret , fmt_str ) x ret = TRIM ( ADJUSTL ( ret )) ELSE WRITE ( ret , * ) x ret = TRIM ( ADJUSTL ( ret )) END IF END FUNCTION int2str CHARACTER ( len = 32 ) FUNCTION real2str ( x , fmt ) DOUBLE PRECISION , INTENT ( in ) :: x CHARACTER ( * ), INTENT ( in ), OPTIONAL :: fmt IF ( PRESENT ( fmt )) THEN write ( real2str , fmt ) x ELSE write ( real2str , * ) x END IF real2str = trim ( adjustl ( real2str )) END FUNCTION real2str FUNCTION generate_static_calculation_path ( rundir , idx , ndigit ) RESULT ( ret ) CHARACTER ( * ), INTENT ( in ) :: rundir INTEGER , INTENT ( in ) :: idx INTEGER , INTENT ( in ) :: ndigit CHARACTER ( 256 ) :: ret CHARACTER ( 32 ) :: fmt_str fmt_str = \"(A,A,I0.\" // TRIM ( int2str ( ndigit )) // \")\" ! \"(A,I0.<ndigit>)\" WRITE ( ret , fmt_str ) TRIM ( rundir ), '/' , idx END FUNCTION generate_static_calculation_path PURE FUNCTION toupper ( str ) RESULT ( ret ) CHARACTER ( * ), INTENT ( in ) :: str CHARACTER ( LEN = LEN ( str )) :: ret INTEGER :: I , J DO i = 1 , LEN ( str ) j = IACHAR ( str ( i : i )) IF ( j >= IACHAR ( \"a\" ) . AND . j <= IACHAR ( \"z\" ) ) THEN ret ( i : i ) = ACHAR ( IACHAR ( str ( i : i )) - 32 ) ELSE ret ( i : i ) = str ( i : i ) END IF END DO END FUNCTION toupper PURE FUNCTION tolower ( str ) RESULT ( ret ) CHARACTER ( * ), INTENT ( in ) :: str CHARACTER ( LEN = LEN ( str )) :: ret INTEGER :: I , J DO i = 1 , LEN ( str ) j = IACHAR ( str ( i : i )) IF ( j >= IACHAR ( \"A\" ) . AND . j <= IACHAR ( \"Z\" ) ) THEN ret ( i : i ) = ACHAR ( IACHAR ( str ( i : i )) + 32 ) ELSE ret ( i : i ) = str ( i : i ) END IF END DO END FUNCTION tolower END MODULE string_mod","tags":"","loc":"sourcefile/string.f90.html"},{"title":"tdm.f90 – NAMD Luminescense","text":"Contents Modules tdm_mod Source Code tdm.f90 Source Code #include \"common.h\" MODULE tdm_mod USE common_mod USE wavecar_mod USE string_mod IMPLICIT NONE INTERFACE tdm_get_tdm_pseudo PROCEDURE tdm_get_tdm_pseudo_qs PROCEDURE tdm_get_tdm_pseudo_q PROCEDURE tdm_get_tdm_wav END INTERFACE tdm_get_tdm_pseudo CONTAINS FUNCTION tdm_get_tdm_pseudo_qs ( phi_i , phi_j , k , de , wavetype ) RESULT ( ret ) COMPLEX ( qs ), INTENT ( in ) :: phi_i (:), phi_j (:) REAL ( q ), INTENT ( in ) :: k (:, :) REAL ( q ), INTENT ( in ) :: de CHARACTER ( * ), INTENT ( in ) :: wavetype COMPLEX ( q ) :: ret ( 3 ) !! local variables INTEGER :: len_i , len_j , len_k COMPLEX ( q ), ALLOCATABLE :: phi_i_q (:), phi_j_q (:) !! logic starts len_i = SIZE ( phi_i ) len_j = SIZE ( phi_j ) len_k = SIZE ( k , 2 ) SELECT CASE ( wavetype ) CASE ( \"std\" , \"gamx\" , \"gamz\" ) IF ( len_i /= len_j . OR . len_i /= len_k ) THEN WRITE ( STDERR , * ) \"Inconsistent length of phi_i=\" // TINT2STR ( len_i ) // \", phi_j=\" & // TINT2STR ( len_j ) // \", kvec=\" // TINT2STR ( len_k ) // \" \" // AT STOP ERROR_TDM_LEN_NOT_EQUAL END IF CASE ( \"ncl\" ) IF ( len_i /= len_j . OR . len_i /= len_k * 2 ) THEN WRITE ( STDERR , * ) \"Inconsistent length of phi_i=\" // TINT2STR ( len_i ) // \", phi_j=\" & // TINT2STR ( len_j ) // \", kvec=\" // TINT2STR ( len_k ) // \" \" // AT STOP ERROR_TDM_LEN_NOT_EQUAL END IF CASE DEFAULT WRITE ( STDERR , * ) 'Invalid wavetype=\"' // wavetype // '\", should be one of \"std\", \"gamx\", \"gamz\" or \"ncl\" ' // AT STOP ERROR_WAVE_WAVETYPE END SELECT ALLOCATE ( phi_i_q ( len_i )) ALLOCATE ( phi_j_q ( len_j )) phi_i_q (:) = phi_i (:) phi_j_q (:) = phi_j (:) ret = tdm_get_tdm_pseudo_q ( phi_i_q , phi_j_q , k , de , wavetype ) DEALLOCATE ( phi_i_q ) DEALLOCATE ( phi_j_q ) RETURN END FUNCTION FUNCTION tdm_get_tdm_pseudo_q ( phi_i , phi_j , k , de , wavetype ) RESULT ( ret ) COMPLEX ( q ), INTENT ( in ) :: phi_i (:), phi_j (:) REAL ( q ), INTENT ( in ) :: k (:, :) REAL ( q ), INTENT ( in ) :: de CHARACTER ( * ), INTENT ( in ) :: wavetype COMPLEX ( q ) :: ret ( 3 ) !! local variables INTEGER :: len_i , len_j , len_k COMPLEX ( q ), ALLOCATABLE :: overlap (:) !<  phi_j(n)' * phi_i(i) !! logic starts len_i = SIZE ( phi_i ) len_j = SIZE ( phi_j ) len_k = SIZE ( k , 2 ) SELECT CASE ( wavetype ) CASE ( \"std\" , \"gamx\" , \"gamz\" ) IF ( len_i /= len_j . OR . len_i /= len_k ) THEN WRITE ( STDERR , * ) \"Inconsistent length of phi_i=\" // TINT2STR ( len_i ) // \", phi_j=\" & // TINT2STR ( len_j ) // \", kvec=\" // TINT2STR ( len_k ) // \" \" // AT STOP ERROR_TDM_LEN_NOT_EQUAL END IF CASE ( \"ncl\" ) IF ( len_i /= len_j . OR . len_i /= len_k * 2 ) THEN WRITE ( STDERR , * ) \"Inconsistent length of phi_i=\" // TINT2STR ( len_i ) // \", phi_j=\" & // TINT2STR ( len_j ) // \", kvec=\" // TINT2STR ( len_k ) // \" \" // AT STOP ERROR_TDM_LEN_NOT_EQUAL END IF CASE DEFAULT WRITE ( STDERR , * ) 'Invalid wavetype=\"' // wavetype // '\", should be one of \"std\", \"gamx\", \"gamz\" or \"ncl\" ' // AT STOP ERROR_WAVE_WAVETYPE END SELECT ALLOCATE ( overlap ( len_i )) !! phi_j(n)' * phi_i(n) IF ( wavetype ( 1 : 3 ) == \"gam\" ) THEN overlap = ( CONJG ( phi_j ) * phi_i - CONJG ( phi_i ) * phi_j ) / 2.0_q ELSE overlap = CONJG ( phi_j ) * phi_i END IF IF ( wavetype == \"ncl\" ) THEN ret = MATMUL ( k , overlap ( 1 : len_k )) + MATMUL ( k , overlap ( len_k + 1 :)) ELSE ret = MATMUL ( k , overlap ) END IF ret = ret * IMGUNIT * AUTOA * AUTODEBYE * ( 2 * RYTOEV ) / de DEALLOCATE ( overlap ) RETURN END FUNCTION FUNCTION tdm_get_tdm_wav ( wav , ispin , ikpoint , iniband , finband ) RESULT ( tdm_ret ) TYPE ( wavecar ), INTENT ( in ) :: wav INTEGER , INTENT ( in ) :: ispin INTEGER , INTENT ( in ) :: ikpoint INTEGER , INTENT ( in ) :: iniband , finband COMPLEX ( q ) :: tdm_ret ( 3 ) !! local variables COMPLEX ( q ), ALLOCATABLE :: phi_i_q (:), phi_j_q (:) COMPLEX ( qs ), ALLOCATABLE :: phi_i_qs (:), phi_j_qs (:) REAL ( q ), ALLOCATABLE :: k (:, :) INTEGER :: nplw INTEGER :: ngvec REAL ( q ) :: de !! logic starts IF ( ispin <= 0 . OR . ispin > wav % nspin ) THEN WRITE ( STDOUT , * ) \"Invalid spin index ispin=\" // TINT2STR ( ispin ) // \", expected: 1<=ispin<=\" // TINT2STR ( wav % nspin ) // \" \" // AT STOP ERROR_WAVE_WRONG_INDEX END IF IF ( ikpoint <= 0 . OR . ikpoint > wav % nspin ) THEN WRITE ( STDOUT , * ) \"Invalid kpoint index ikpoint=\" // TINT2STR ( ikpoint ) // \", expected: 1<=ikpoint<=\" // TINT2STR ( wav % nkpoints ) // \" \" // AT STOP ERROR_WAVE_WRONG_INDEX END IF IF ( iniband <= 0 . OR . iniband > wav % nbands . OR . & finband <= 0 . OR . finband > wav % nbands . OR . & iniband >= finband ) THEN WRITE ( STDOUT , * ) \"Invalid band index iniband=\" // TINT2STR ( iniband ) // \", finband=\" // TINT2STR ( finband ) // & \", expected 1<=(ini,fin)<=\" // TINT2STR ( wav % nbands ) // \" and iniband < finband \" // AT STOP ERROR_WAVE_WRONG_INDEX END IF nplw = wav % nplws ( ikpoint ) ngvec = nplw IF ( wav % wavetype == \"ncl\" ) ngvec = ngvec / 2 ALLOCATE ( k ( 3 , ngvec )) CALL wavecar_get_gvecs_cart ( wav , ikpoint , k ) de = ABS ( wav % eigs ( finband , ikpoint , ispin ) - wav % eigs ( iniband , ikpoint , ispin )) IF ( wav % prec == qs ) THEN ALLOCATE ( phi_i_qs ( nplw )) ALLOCATE ( phi_j_qs ( nplw )) CALL wavecar_read_wavefunction ( wav , ispin , ikpoint , iniband , phi_i_qs ) CALL wavecar_read_wavefunction ( wav , ispin , ikpoint , finband , phi_j_qs ) tdm_ret = tdm_get_tdm_pseudo_qs ( phi_i_qs , phi_j_qs , k , de , wav % wavetype ) DEALLOCATE ( phi_j_qs ) DEALLOCATE ( phi_i_qs ) ELSE ALLOCATE ( phi_i_q ( nplw )) ALLOCATE ( phi_j_q ( nplw )) CALL wavecar_read_wavefunction ( wav , ispin , ikpoint , iniband , phi_i_q ) CALL wavecar_read_wavefunction ( wav , ispin , ikpoint , finband , phi_j_q ) tdm_ret = tdm_get_tdm_pseudo_q ( phi_i_q , phi_j_q , k , de , wav % wavetype ) DEALLOCATE ( phi_j_q ) DEALLOCATE ( phi_i_q ) END IF DEALLOCATE ( k ) END FUNCTION END MODULE tdm_mod","tags":"","loc":"sourcefile/tdm.f90.html"},{"title":"lib.f90 – NAMD Luminescense","text":"Contents Modules namd_lumi_mod Source Code lib.f90 Source Code MODULE namd_lumi_mod USE string_mod USE common_mod USE input_mod USE wavecar_mod USE tdm_mod USE nac_mod USE hamiltonian_mod USE surface_hopping_mod END MODULE namd_lumi_mod","tags":"","loc":"sourcefile/lib.f90.html"},{"title":"surface_hopping.f90 – NAMD Luminescense","text":"Contents Modules surface_hopping_mod Source Code surface_hopping.f90 Source Code #include \"common.h\" MODULE surface_hopping_mod USE common_mod USE string_mod USE hamiltonian_mod IMPLICIT NONE TYPE :: surface_hopping CHARACTER ( len = 32 ) :: shmethod CHARACTER ( len = 32 ) :: propmethod INTEGER :: ntraj REAL ( q ), ALLOCATABLE :: sh_prob (:, :, :) !< cumulated surface hopping probability, !< sh_prob[i]-sh_prob[i-1] is the real probability, [nbasis, nbasis, namdtime] REAL ( q ), ALLOCATABLE :: sh_pops (:, :) !< population after surface hopping, [nbasis, namdtime] REAL ( q ), ALLOCATABLE :: sh_eigs (:) !< Total energy of system END TYPE surface_hopping PRIVATE :: sh_fssh_ PRIVATE :: sh_dcsh_ PRIVATE :: sh_dish_ CONTAINS SUBROUTINE surface_hopping_init ( sh , hamil , propmethod , shmethod , ntraj ) TYPE ( surface_hopping ), INTENT ( inout ) :: sh TYPE ( hamiltonian ), INTENT ( in ) :: hamil CHARACTER ( LEN =* ), INTENT ( in ) :: propmethod CHARACTER ( LEN =* ), INTENT ( in ) :: shmethod INTEGER , INTENT ( in ) :: ntraj !! logic starts sh % ntraj = ntraj sh % propmethod = toupper ( propmethod ) sh % shmethod = toupper ( shmethod ) ALLOCATE ( sh % sh_prob ( hamil % nbasis , hamil % nbasis , hamil % namdtime )) ALLOCATE ( sh % sh_pops ( hamil % nbasis , hamil % namdtime )) ALLOCATE ( sh % sh_eigs ( hamil % namdtime )) sh % sh_prob = 0 sh % sh_pops = 0 sh % sh_eigs = 0 END SUBROUTINE surface_hopping_init SUBROUTINE surface_hopping_init_with_input ( sh , hamil , inp ) TYPE ( surface_hopping ), INTENT ( inout ) :: sh TYPE ( hamiltonian ), INTENT ( in ) :: hamil TYPE ( input ), INTENT ( in ) :: inp CALL surface_hopping_init ( sh , hamil , inp % propmethod , inp % shmethod , inp % ntraj ) END SUBROUTINE surface_hopping_init_with_input SUBROUTINE surface_hopping_destroy ( sh ) TYPE ( surface_hopping ), INTENT ( inout ) :: sh IF ( ALLOCATED ( sh % sh_prob )) DEALLOCATE ( sh % sh_prob ) IF ( ALLOCATED ( sh % sh_pops )) DEALLOCATE ( sh % sh_pops ) IF ( ALLOCATED ( sh % sh_eigs )) DEALLOCATE ( sh % sh_eigs ) END SUBROUTINE surface_hopping_destroy SUBROUTINE surface_hopping_run ( sh , hamil , irank ) TYPE ( surface_hopping ), INTENT ( inout ) :: sh TYPE ( hamiltonian ), INTENT ( inout ) :: hamil INTEGER , INTENT ( in ) :: irank !! local variables INTEGER :: timing_start , timing_end , timing_rate REAL ( q ) :: time INTEGER :: iion , rtime CALL SYSTEM_CLOCK ( timing_start , timing_rate ) SELECT CASE ( sh % shmethod ) CASE ( \"FSSH\" ) CALL sh_fssh_ ( sh , hamil ) CASE ( \"DCSH\" ) CALL sh_dcsh_ ( sh , hamil ) CASE ( \"DISH\" ) CALL sh_dish_ ( sh , hamil ) CASE DEFAULT WRITE ( STDERR , '(\"[ERROR] Invalid method for surface_hopping_run: \", A, \" , available: FSSH, DCSH, DISH.\")' ) sh % shmethod STOP ERROR_SURFHOP_METHOD END SELECT CALL SYSTEM_CLOCK ( timing_end , timing_rate ) time = DBLE ( timing_end - timing_start ) / timing_rate CALL surface_hopping_print_stat ( hamil , time , irank ) DO iion = 1 , hamil % namdtime rtime = MOD ( iion + hamil % namdinit - 2 , hamil % nsw - 1 ) + 1 sh % sh_eigs ( iion ) = SUM ( sh % sh_pops (:, iion ) * hamil % eig_t (:, rtime )) ENDDO END SUBROUTINE surface_hopping_run SUBROUTINE surface_hopping_run_mpi ( nac_dat , inp ) USE mpi USE input_mod USE nac_mod TYPE ( nac ), INTENT ( in ) :: nac_dat TYPE ( input ), INTENT ( in ) :: inp !! local variables TYPE ( hamiltonian ) :: hamil TYPE ( surface_hopping ) :: sh INTEGER , ALLOCATABLE :: sendcounts (:) INTEGER , ALLOCATABLE :: displs (:) INTEGER :: nsample INTEGER :: irank , nrank INTEGER :: i INTEGER :: local_start , local_end INTEGER :: ierr CALL MPI_COMM_RANK ( MPI_COMM_WORLD , irank , ierr ) CALL MPI_COMM_SIZE ( MPI_COMM_WORLD , nrank , ierr ) nsample = inp % nsample IF ( nrank > nsample ) THEN WRITE ( STDERR , '(\"[ERROR] Number of MPI processes larger than NSAMPLE (\", I4, \">\", I4, \"), please consider reduce the MPI processes\")' ) & nrank , nsample STOP ERROR_NRANKGTNSAMPLE ENDIF ALLOCATE ( sendcounts ( nrank )) ALLOCATE ( displs ( nrank )) CALL mpi_partition ( nrank , nsample , sendcounts , displs ) local_start = displs ( irank + 1 ) + 1 local_end = local_start + sendcounts ( irank + 1 ) - 1 WRITE ( STDOUT , '(A, I4, A)' ) \"[NODE\" , irank , \"] This node will run surface hopping for INICON from \" // & TINT2STR ( inp % inisteps ( local_start )) // \" to \" // TINT2STR ( inp % inisteps ( local_end )) DO i = local_start , local_end WRITE ( STDOUT , '(A, I4, A, I5, A)' ) \"[NODE\" , irank , \"] Running INICON = \" , inp % inisteps ( i ), \" ...\" CALL hamiltonian_init_with_input ( hamil , nac_dat , inp , i ) IF ( i == 1 ) CALL hamiltonian_save_to_h5 ( hamil , \"HAMIL.h5\" , llog = . TRUE .) CALL surface_hopping_init_with_input ( sh , hamil , inp ) CALL surface_hopping_run ( sh , hamil , irank ) CALL surface_hopping_save_to_h5 ( sh , hamil , inp % ndigit , irank , llog = . TRUE .) CALL surface_hopping_destroy ( sh ) CALL hamiltonian_destroy ( hamil ) ENDDO DEALLOCATE ( displs ) DEALLOCATE ( sendcounts ) END SUBROUTINE surface_hopping_run_mpi FUNCTION surface_hopping_hopping_destination ( sh_prob_cum ) RESULT ( des ) REAL ( q ), INTENT ( in ) :: sh_prob_cum (:) INTEGER :: des !! local variables INTEGER :: N REAL ( q ) :: val !! logic starts N = SIZE ( sh_prob_cum ) CALL RANDOM_NUMBER ( val ) des = lower_bound ( sh_prob_cum , val ) des = MOD ( des , N + 1 ) END FUNCTION surface_hopping_hopping_destination !> Hopping probability !> P_{jk} = \\max[\\frac{2*\\int_t&#94;{t+\\Delta t} Re(\\rho_{jk}*d_{jk}) dt}{\\rho_{jj}}, 0] SUBROUTINE surface_hopping_calc_hop_prob ( sh , hamil , iion , istate ) TYPE ( surface_hopping ), INTENT ( inout ) :: sh TYPE ( hamiltonian ), INTENT ( in ) :: hamil INTEGER , INTENT ( in ) :: iion INTEGER , INTENT ( in ) :: istate !! local variables INTEGER :: i INTEGER :: rtime REAL ( q ) :: rho_jj REAL ( q ), ALLOCATABLE , SAVE :: thermal_factor (:) !< use SAVE attribute to avoid repetitive allocations REAL ( q ), ALLOCATABLE , SAVE :: rhod_jk (:) REAL ( q ), ALLOCATABLE , SAVE :: prob (:) REAL ( q ), ALLOCATABLE , SAVE :: dE (:) !! logic starts rtime = MOD ( iion + hamil % namdinit - 2 , hamil % nsw - 1 ) + 1 IF (. NOT . ALLOCATED ( thermal_factor )) ALLOCATE ( thermal_factor ( hamil % nbasis )) IF (. NOT . ALLOCATED ( rhod_jk )) ALLOCATE ( rhod_jk ( hamil % nbasis )) IF (. NOT . ALLOCATED ( prob )) ALLOCATE ( prob ( hamil % nbasis )) IF (. NOT . ALLOCATED ( dE )) ALLOCATE ( dE ( hamil % nbasis )) rho_jj = REALPART ( CONJG ( hamil % psi_t ( istate , iion )) * hamil % psi_t ( istate , iion )) rhod_jk = REALPART ( CONJG ( hamil % psi_t ( istate , iion )) * hamil % psi_t (:, iion ) * hamil % nac_t ( istate , :, rtime )) !< Re(rho_jk * d_jk) !< Boltzmann factor only works for upward hoppings, i.e. dE < 0 FORALL ( i = 1 : hamil % nbasis ) dE ( i ) = MIN ( 0.0_q , hamil % eig_t ( istate , rtime ) - hamil % eig_t ( i , rtime )) thermal_factor = EXP ( dE / ( BOLKEV * hamil % temperature )) !< exp(-dE/kbT) prob = 2 * rhod_jk * hamil % dt / rho_jj !< P_jk_ = 2 * Re(rho_jk * d_jk) * dt / rho_jj prob = prob * thermal_factor FORALL ( i = 1 : hamil % nbasis , prob ( i ) < 0 ) prob ( i ) = 0.0 !! P_jk = max(P_jk_, 0) CALL cumsum ( prob , sh % sh_prob ( istate , :, iion )) !< calculate the accumulated prob END SUBROUTINE surface_hopping_calc_hop_prob SUBROUTINE surface_hopping_save_to_h5 ( sh , hamil , ndigit , irank , llog ) USE hdf5 TYPE ( surface_hopping ), INTENT ( in ) :: sh TYPE ( hamiltonian ), INTENT ( in ) :: hamil INTEGER , INTENT ( in ) :: ndigit INTEGER , INTENT ( in ) :: irank LOGICAL , OPTIONAL :: llog !! local variables CHARACTER ( FNAMELEN ) :: h5fname REAL ( q ), ALLOCATABLE :: time_idx (:) INTEGER :: i INTEGER :: ierr INTEGER ( HSIZE_T ) :: time_dims ( 1 ), propagation_dims ( 2 ), shpop_dims ( 2 ) INTEGER ( HID_T ) :: file_id , dspace_id , dset_id !! logic starts ALLOCATE ( time_idx ( hamil % namdtime )) FORALL ( i = 1 : hamil % namdtime ) time_idx ( i ) = i * hamil % dt time_dims = [ hamil % namdtime ] !! propagation h5fname = \"propagation_\" // TRIM ( int2str ( hamil % namdinit , ndigit = ndigit )) // \".h5\" IF ( PRESENT ( llog )) THEN IF ( llog ) WRITE ( STDOUT , '(A, I4, A)' ) '[NODE' , irank , '] Writing propagation info to \"' // TRIM ( h5fname ) // '\" ...' ENDIF CALL H5OPEN_F ( ierr ) CALL H5FCREATE_F ( TRIM ( h5fname ), H5F_ACC_TRUNC_F , file_id , ierr ) CALL H5SCREATE_SIMPLE_F ( 1 , time_dims , dspace_id , ierr ) !! time indices CALL H5DCREATE_F ( file_id , \"time\" , H5T_NATIVE_DOUBLE , dspace_id , dset_id , ierr ) CALL H5DWRITE_F ( dset_id , H5T_NATIVE_DOUBLE , time_idx , time_dims , ierr ) CALL H5DCLOSE_F ( dset_id , ierr ) !! evolution of system's energy CALL H5DCREATE_F ( file_id , \"energy\" , H5T_NATIVE_DOUBLE , dspace_id , dset_id , ierr ) CALL H5DWRITE_F ( dset_id , H5T_NATIVE_DOUBLE , hamil % prop_eigs , time_dims , ierr ) CALL H5DCLOSE_F ( dset_id , ierr ) CALL H5SCLOSE_F ( dspace_id , ierr ) !! psi_t propagation_dims = SHAPE ( hamil % psi_t ) CALL H5SCREATE_SIMPLE_F ( 2 , propagation_dims , dspace_id , ierr ) !! real part CALL H5DCREATE_F ( file_id , \"psi_t_r\" , H5T_NATIVE_DOUBLE , dspace_id , dset_id , ierr ) CALL H5DWRITE_F ( dset_id , H5T_NATIVE_DOUBLE , REALPART ( hamil % psi_t ), propagation_dims , ierr ) CALL H5DCLOSE_F ( dset_id , ierr ) !! imag part CALL H5DCREATE_F ( file_id , \"psi_t_i\" , H5T_NATIVE_DOUBLE , dspace_id , dset_id , ierr ) CALL H5DWRITE_F ( dset_id , H5T_NATIVE_DOUBLE , IMAGPART ( hamil % psi_t ), propagation_dims , ierr ) CALL H5DCLOSE_F ( dset_id , ierr ) CALL H5SCLOSE_F ( dspace_id , ierr ) CALL H5FCLOSE_F ( file_id , ierr ) CALL H5CLOSE_F ( ierr ) !! surface hopping h5fname = \"shpop_\" // TRIM ( int2str ( hamil % namdinit , ndigit = ndigit )) // \".h5\" IF ( PRESENT ( llog )) THEN IF ( llog ) WRITE ( STDOUT , '(A, I4, A)' ) '[INFO' , irank , '] Writing surface hopping info to \"' // TRIM ( h5fname ) // '\" ...' ENDIF CALL H5OPEN_F ( ierr ) CALL H5FCREATE_F ( TRIM ( h5fname ), H5F_ACC_TRUNC_F , file_id , ierr ) CALL H5SCREATE_SIMPLE_F ( 1 , time_dims , dspace_id , ierr ) !! time indices CALL H5DCREATE_F ( file_id , \"time\" , H5T_NATIVE_DOUBLE , dspace_id , dset_id , ierr ) CALL H5DWRITE_F ( dset_id , H5T_NATIVE_DOUBLE , time_idx , time_dims , ierr ) CALL H5DCLOSE_F ( dset_id , ierr ) !! evolution of system's energy CALL H5DCREATE_F ( file_id , \"energy\" , H5T_NATIVE_DOUBLE , dspace_id , dset_id , ierr ) CALL H5DWRITE_F ( dset_id , H5T_NATIVE_DOUBLE , sh % sh_eigs , time_dims , ierr ) CALL H5DCLOSE_F ( dset_id , ierr ) CALL H5SCLOSE_F ( dspace_id , ierr ) !! sh_pops shpop_dims = SHAPE ( sh % sh_pops ) CALL H5SCREATE_SIMPLE_F ( 2 , shpop_dims , dspace_id , ierr ) CALL H5DCREATE_F ( file_id , \"shpops\" , H5T_NATIVE_DOUBLE , dspace_id , dset_id , ierr ) CALL H5DWRITE_F ( dset_id , H5T_NATIVE_DOUBLE , sh % sh_pops , shpop_dims , ierr ) CALL H5DCLOSE_F ( dset_id , ierr ) CALL H5SCLOSE_F ( dspace_id , ierr ) CALL H5FCLOSE_F ( file_id , ierr ) CALL H5CLOSE_F ( ierr ) DEALLOCATE ( time_idx ) END SUBROUTINE surface_hopping_save_to_h5 SUBROUTINE surface_hopping_print_stat ( hamil , time , irank ) TYPE ( hamiltonian ), INTENT ( in ) :: hamil INTEGER , INTENT ( in ) :: irank REAL ( q ), INTENT ( in ) :: time WRITE ( STDOUT , 100 ) irank , hamil % namdinit , time 100 FORMAT ( \"[NODE\" , I4 , \"] NAMDINIT = \" , I5 , \" Time used: \" , F10 . 3 , \" secs\" ) END SUBROUTINE surface_hopping_print_stat !! private subroutines SUBROUTINE sh_fssh_ ( sh , hamil ) TYPE ( surface_hopping ), INTENT ( inout ) :: sh TYPE ( hamiltonian ), INTENT ( inout ) :: hamil INTEGER :: i INTEGER :: iion INTEGER :: inistate , curstate INTEGER :: istate INTEGER :: hop_dest sh % sh_prob = 0 sh % sh_pops = 0 inistate = MAXLOC ( ABS ( hamil % psi_c ), DIM = 1 ) !! propagate DO iion = 1 , hamil % namdtime CALL hamiltonian_propagate ( hamil , iion , sh % propmethod ) ENDDO DO iion = 1 , hamil % namdtime DO istate = 1 , hamil % nbasis CALL surface_hopping_calc_hop_prob ( sh , hamil , iion , istate ) ENDDO ENDDO DO i = 1 , sh % ntraj curstate = inistate DO iion = 1 , hamil % namdtime hop_dest = surface_hopping_hopping_destination ( sh % sh_prob ( curstate , :, iion )) IF ( hop_dest > 0 ) curstate = hop_dest sh % sh_pops ( curstate , iion ) = sh % sh_pops ( curstate , iion ) + 1 ENDDO ENDDO sh % sh_pops = sh % sh_pops / sh % ntraj END SUBROUTINE sh_fssh_ SUBROUTINE sh_dcsh_ ( sh , hamil ) TYPE ( surface_hopping ), INTENT ( inout ) :: sh TYPE ( hamiltonian ), INTENT ( inout ) :: hamil WRITE ( STDERR , * ) \"This SHMETHOD not implemented yet: \" // AT STOP 1 END SUBROUTINE sh_dcsh_ SUBROUTINE sh_dish_ ( sh , hamil ) TYPE ( surface_hopping ), INTENT ( inout ) :: sh TYPE ( hamiltonian ), INTENT ( inout ) :: hamil WRITE ( STDERR , * ) \"This SHMETHOD not implemented yet: \" // AT STOP 1 END SUBROUTINE sh_dish_ SUBROUTINE sh_dish_dephasetime_ END SUBROUTINE sh_dish_dephasetime_ SUBROUTINE sh_dish_decoherence_rate_ END SUBROUTINE sh_dish_decoherence_rate_ END MODULE surface_hopping_mod","tags":"","loc":"sourcefile/surface_hopping.f90.html"}]}